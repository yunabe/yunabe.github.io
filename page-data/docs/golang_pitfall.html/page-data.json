{"componentChunkName":"component---src-templates-post-js","path":"/docs/golang_pitfall.html","webpackCompilationHash":"935b56914147422a1df1","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://golang.org/ref/spec\">Go の言語仕様</a>はシンプルで他の言語に比べてはまりどころが少なくて学習コストが小さめな言語のように思います。しかし、それでもはまるところがないわけではないので、自分がはまって時間を無駄にしてしまったことを書き留めておきます。</p>\n<p>念の為誤解のないように追記しておくと、この文書の目的は Go を批判することではなく Go が Go であるがゆえに C++/Java/Python など利用者が Go を使い始めるときに困惑あるいは誤解するであろうポイントをまとめておくことで初めて Go を触る人がスムーズに Go を使い始められるようにすることです。<a href=\"why_golang_is_good.html\">私個人は Go はバランスがとれた良い言語でだと思いますし、気に入っています</a>。</p>\n<h2 id=\"interface-と-nil-go-の-interface-は単なる参照ではない\"><a href=\"#interface-%E3%81%A8-nil-go-%E3%81%AE-interface-%E3%81%AF%E5%8D%98%E3%81%AA%E3%82%8B%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84\" aria-label=\"interface と nil go の interface は単なる参照ではない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>interface と nil (Go の interface は単なる参照ではない)</h2>\n<p>Java や C#あるいは C++の経験があり、ある程度クラスの内部構造への理解がある人は Go の interface の実体もデータへの参照だと考えると思います。\nしかし実はそれは正しくありません。Go の interface の実体は参照(ポインタ)ではありません。<a href=\"http://research.swtch.com/interfaces\">Go の interface の実体は参照と型情報のペアです</a>。</p>\n<p>さてこの内部構造の違いが Go にどういった影響をもたらすのでしょうか。実はこの内部構造の違い、意外と言語の挙動にはあまり大きな影響を与えません。そのためこの点を理解していなくても Go でプログラムを書けてしまいます。ただし nil を扱う場合には Go は予想外の挙動をします。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"reflect\"</span>\n\n<span class=\"token keyword\">type</span> myError <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\tmessage <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">*</span>myError<span class=\"token punctuation\">)</span> <span class=\"token function\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> e <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"myError: &lt;nil>\"</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"myError: \"</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>message\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">myFunc</span><span class=\"token punctuation\">(</span>x <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">var</span> err <span class=\"token operator\">*</span>myError\n\t<span class=\"token keyword\">if</span> x <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\t\terr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>myError<span class=\"token punctuation\">{</span>\n\t\t\tmessage<span class=\"token punctuation\">:</span> <span class=\"token string\">\"x should be positive or zero.\"</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> err\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\terr <span class=\"token operator\">:=</span> <span class=\"token function\">myFunc</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"err is NOT nil.\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"err is nil.\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"---- err ----\"</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"is nil:\"</span><span class=\"token punctuation\">,</span> err <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Type:\"</span><span class=\"token punctuation\">,</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">TypeOf</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value:\"</span><span class=\"token punctuation\">,</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token keyword\">var</span> trueNil <span class=\"token builtin\">error</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"---- trueNil ----\"</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"is nil:\"</span><span class=\"token punctuation\">,</span> trueNil <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Type:\"</span><span class=\"token punctuation\">,</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">TypeOf</span><span class=\"token punctuation\">(</span>trueNil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Value:\"</span><span class=\"token punctuation\">,</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>trueNil<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"https://play.golang.org/p/ClzTEOs_P-\">上のコード(Go Playground)</a>では、myFunc は<code>x >= 0</code>の時には<code>var err *myError</code>の初期値<code>nil</code>を返すので、main の最初の<code>fmt.Println(err)</code>は<code>myError: &#x3C;nil></code>を出力します。そして、次の if-else は err が nil だから\"err is nil.\"が表示されると思うかもしれません。Java や C++ならそうなります。しかし Go では\"err is NOT nil\"が表示されます。</p>\n<p>何故こうなるのかは、interface が型と値への参照のペアであること点を踏まえた上で、err の Value と Type を<code>reflect.ValueOf</code>, <code>reflect.TypeOf</code>を使って表示してみると明らかです。\nerr の Type と Value を表示してみると、Type が<code>*main.myError</code>で値が Value が<code>&#x3C;nil></code>であることが分かります。err の\"値\"は<code>nil</code>ですが err は型情報を保持しているのです。\n型を持っている interface は Value が<code>nil</code>でも<code>nil</code>ではないのです。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">---- err ----\nis nil: false\nType: *main.myError\nValue: &lt;nil&gt;\n---- trueNil ----\nis nil: true\nType: &lt;nil&gt;\nValue: &lt;invalid reflect.Value&gt;</code></pre></div>\n<p>ちなみにこれは<a href=\"https://golang.org/doc/faq#nil_error\">Frequently Asked Questions (FAQ)</a>に<a href=\"https://github.com/golang/go/commit/1e0f97ac6544ab3b7cf76e9c9d62e8c2a60bcdb6\">2012 年から</a>書いてある問題です。\nよくドキュメントを読まずに色々はまって時間をつぶすす前に(自分は数時間つぶしました)、まず FAQ くらいは目を通しておいたほうがよいですね。</p>\n<h3 id=\"文献\"><a href=\"#%E6%96%87%E7%8C%AE\" aria-label=\"文献 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>文献</h3>\n<ul>\n<li><a href=\"https://golang.org/doc/faq#nil_error\">Why is my nil error value not equal to nil?</a></li>\n<li><a href=\"http://blog.golang.org/laws-of-reflection\">The Laws of Reflection - The Go Blog</a></li>\n<li><a href=\"http://research.swtch.com/interfaces\">Go Data Structures: Interfaces</a></li>\n</ul>\n<h2 id=\"メソッド内でレシーバthis-selfが-nil-でないことをチェックすることに意味がある\"><a href=\"#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%86%85%E3%81%A7%E3%83%AC%E3%82%B7%E3%83%BC%E3%83%90this-self%E3%81%8C-nil-%E3%81%A7%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%82%92%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E6%84%8F%E5%91%B3%E3%81%8C%E3%81%82%E3%82%8B\" aria-label=\"メソッド内でレシーバthis selfが nil でないことをチェックすることに意味がある permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>メソッド内でレシーバ(this, self)が nil でないことをチェックすることに意味がある</h2>\n<p>これははまりどころというより、Go だと<code>nil</code>に大してメソッド呼び出しを行った場合の挙動が他の人気のある言語と少し異なるので、メソッド側の書き方次第では呼び出し側の<code>nil</code>チェックをすこし緩和できるよという話ですが。あるいはこの点を理解していないと、呼び出し側で<code>nil</code>チェックしなくてなぜ大丈夫なのか困惑するという話です。</p>\n<p>C++, Java, Python, JavaScript などの他の人気のある言語では</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">person.sayHello()</code></pre></div>\n<p>のようにメソッド呼び出しをする場合は(C++の場合は<code>.</code>でなく<code>-></code>)、<code>person</code>が<code>null</code>でないことを確認しなくてはなりません(C++で<code>sayHello</code>が non-virtual の場合も挙動は未定義)。\nしかし Go の場合は<code>person</code>が<code>struct</code>のポインタである場合には<code>person</code>が<code>nil</code>でも関数の呼び出しは問題なく行えます。\nまた<code>person</code>がインターフェイスでその値が<code>nil</code>で型情報が<code>struct</code>のポインタである(つまり上述したようにインターフェイスそのものは<code>nil</code>ではない)場合にも、問題なく関数は呼び出されます。</p>\n<p>そのため、Go ではメソッド内部でレシーバのポインタが<code>nil</code>であるかを確認することには意味があります。\nメソッド内で<code>nil</code>のチェックが適切に行われている場合、そのメッソドは呼び出し側で<code>nil</code>チェックをすることなしに呼び出せるようになります。\n例えば<a href=\"https://github.com/golang/protobuf\">Go の protobuf の実装</a>はレシーバが<code>nil</code>の場合でも getter メッソドは問題なく実行できるように実装されています\n(<em>There are getters that return a field's value if set, and return the field's default value if unset. The getters work even if the receiver is a nil message.</em>)。\nそのため Go の protobuf を利用する場合、例え<code>GetDoc()</code>の返り値が<code>nil</code>だったとしても</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> url <span class=\"token builtin\">string</span>\ndoc <span class=\"token operator\">:=</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">GetDoc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> doc <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\turl <span class=\"token operator\">=</span> doc<span class=\"token punctuation\">.</span><span class=\"token function\">GetURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>のように書かずに単純に</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">url <span class=\"token operator\">:=</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">GetDoc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">GetURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>のように書くことが出来ます(GetURL の内部で doc が<code>nil</code>かどうかがチェックされている)。呼び出し側での<code>nil</code>チェックの必要性は細かいことですが、<code>protobuf</code>のようなライブラリの使い勝手には大きく影響します。\nメソッド内部でレシーバの<code>nil</code>チェックが行われていない場合は、レシーバ内で<code>recv.field</code>を参照した時点、値を代入しようとした時点で<code>panic</code>が発生します。</p>\n<iframe src=\"https://play.golang.org/p/fQ_0Jzu8M6\" frameborder=\"0\" style=\"width: 100%; height: 400px\"><a href=\"https://play.golang.org/p/fQ_0Jzu8M6\">see this code in play.golang.org</a></iframe>\n<h2 id=\"error-しか返り値がない関数で-error-を処理し忘れる\"><a href=\"#error-%E3%81%97%E3%81%8B%E8%BF%94%E3%82%8A%E5%80%A4%E3%81%8C%E3%81%AA%E3%81%84%E9%96%A2%E6%95%B0%E3%81%A7-error-%E3%82%92%E5%87%A6%E7%90%86%E3%81%97%E5%BF%98%E3%82%8C%E3%82%8B\" aria-label=\"error しか返り値がない関数で error を処理し忘れる permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>error しか返り値がない関数で error を処理し忘れる</h2>\n<p>Go ではエラーは通常、最後の返り値として呼び出し元に返されます。関数が何か重要な値を返す場合であれば、<code>_</code>を利用しないかぎりは error は無視できないので error を処理し忘れることはあまりないと思います。ただ<a href=\"https://golang.org/pkg/encoding/json/#Unmarshal\">json.Unmarshal</a>のような error 以外に重要な情報を返さない関数は、エラー以外に返り値がないからといって、うっかり返り値を受け取るのを忘れると error が失われます。</p>\n<iframe src=\"https://play.golang.org/p/E9UM39VxQx\" frameborder=\"0\" style=\"width: 100%; height: 400px\"><a href=\"https://play.golang.org/p/E9UM39VxQx\">see this code in play.golang.org</a></iframe>\n<p>例えば上のコードは<code>\"not json\"</code>は json としてパース出来ないのでエラーが発生しますが、コンパイル時にはエラーが無視されていることは検出されません。これに関しては気をつける以外に解決策はないと思います。</p>\n<h2 id=\"defer-の中で発生した-error-を処理し忘れる\"><a href=\"#defer-%E3%81%AE%E4%B8%AD%E3%81%A7%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F-error-%E3%82%92%E5%87%A6%E7%90%86%E3%81%97%E5%BF%98%E3%82%8C%E3%82%8B\" aria-label=\"defer の中で発生した error を処理し忘れる permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>defer の中で発生した error を処理し忘れる</h2>\n<p>Go (golang) ではファイルを閉じたりセッションを閉じたりといった、リソースの解放処理は<code>defer</code>で行います。\n<code>defer x.Close()</code>みたいなコードを書くことが多くあると思います。\n<a href=\"https://blog.golang.org/defer-panic-and-recover\">Go Blog の defer, panic and recover</a>にも似たようなコードがあります。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">WriteSomeData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span>\n\tw <span class=\"token operator\">:=</span> <span class=\"token function\">OpenData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> w<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> w<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"....\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> err\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// Write more to w...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>このコード問題ないようにみえます。そもそも Go Blog ほぼ同じものが書かれているのだから問題がないはずです。</p>\n<p>しかしこのコードでは重大なことが忘れ去られてしまっています。<code>Close</code>の定義は<a href=\"https://golang.org/pkg/io/#Closer\"><code>Close() error</code></a>でありエラーを返す可能性があるのです。現実のコードでは<code>Close()</code>でエラーが発生するような場合は<code>Close()</code>よりも前の段階の処理でエラーが発生しがちなので<code>Close()</code>のエラーを無視してしまっていても、あまり問題にならないのかもしれません。しかし<code>Close() error</code>がエラーを返す以上、ライブラリや状況によっては重要なエラーが<code>Close()</code>の段階になって初めて発生する可能性も十分にありえます。その場合にはエラーは完全に消失してしまうので実行結果がおかしいけれどエラーはどこにも出ないという非常に厄介な状態になります。そのため、<code>defer</code>で関数を呼び出す場合はその関数が<code>error</code>を返すことがないか慎重にチェックすべきです。Go Blog の記事ではチェックされていませんが。</p>\n<p>問題はどのように関数の終了し返り値も決定された後に実行される<code>defer</code>の内部で生じた<code>error</code>を処理するかです。結論としては<code>defer</code>内部で発生した<code>error</code>を処理するのには名前付き返り値を利用します。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">WriteSomeData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>err <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tw <span class=\"token operator\">:=</span> <span class=\"token function\">OpenData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tcerr <span class=\"token operator\">:=</span> w<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">if</span> cerr <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">return</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\terr <span class=\"token operator\">=</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Errorf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Failed to close: %v, the original error was %v\"</span><span class=\"token punctuation\">,</span> cerr<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> w<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"....\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> err\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// Write more to w...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>このように<code>defer</code>の中で発生した<code>error</code>を呼び出し元に返すには</p>\n<ul>\n<li>返り値の<code>error</code>を<code>defer</code>から上書きできるように名前(<code>err</code>)をつけておく</li>\n<li><code>defer</code>で直接<code>w.Close()</code>を呼ぶのではなく、<code>w.Close()</code>の返り値をチェックしてエラーが発生したら<code>err</code>を上書きするような関数を呼び出す</li>\n<li><code>err</code>の元の値にも重要なエラー情報が入っている可能性があるので、間違って <code>err = w.Close()</code> などとして上書きして消してしまわないように注意が必要。</li>\n</ul>\n<p>うーん随分冗長ですね。これは間違えやすいように思いますし、もう少し賢くとりあつかえるように言語仕様が変わるとうれしいですね。\n<code>error</code>を明示的に扱わなければ行けない一方、うっかり<code>error</code>を処理し損なうと<code>error</code>が完全にどこかに消えてしまうのはエラー処理に例外を使用しない Go の割りと致命的な欠陥のように思うので、将来うまく扱う方法が現れるとよいです。</p>\n<h2 id=\"基本型がメソッドを持たない\"><a href=\"#%E5%9F%BA%E6%9C%AC%E5%9E%8B%E3%81%8C%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%92%E6%8C%81%E3%81%9F%E3%81%AA%E3%81%84\" aria-label=\"基本型がメソッドを持たない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>基本型がメソッドを持たない</h2>\n<p><a href=\"https://golang.org/doc/faq#methods_on_basics\">例えば string が len をメソッドとして持ちません</a>。これは<a href=\"https://msdn.microsoft.com/ja-jp/library/system.int32.aspx\">C#とかでは int ですらメソッドを持つ</a>のと真逆を行くように思える。\nGo のインターフェースで宣言されているメソッドが実装されていれば、そのインターフェースを実装していることになるという仕様と関係している？</p>\n<h2 id=\"string-が単なるバイト列\"><a href=\"#string-%E3%81%8C%E5%8D%98%E3%81%AA%E3%82%8B%E3%83%90%E3%82%A4%E3%83%88%E5%88%97\" aria-label=\"string が単なるバイト列 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>string が単なるバイト列</h2>\n<p>Java, C#や Python3 などのモダンな言語では文字列(string)は Unicode 文字の列ですが、<a href=\"https://blog.golang.org/strings\">Go 言語の string は単なる immutable(書き換え不可能)なバイト列に過ぎません(In Go, a string is in effect a read-only slice of bytes.)</a>。Go の string は中身が UTF-8 でエンコードされた文字列かも知れませんし、Shift_JIS でエンコードされた文字列かもしれません。</p>\n<p><a href=\"https://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit\">これは文字列を Unicode にした Python3</a>の真逆を行く感じで正直本当に正しいのかはよく分かりません。</p>\n<ul>\n<li>Go ではファイルなどから<code>string</code>を読み込む際にエンコードを指定したりはしません。\n<a href=\"https://docs.oracle.com/javase/jp/6/api/java/io/FileReader.html\">これは他の言語のようにデフォルトの文字エンコーディングで暗黙的にデコードされている</a>のではなく、\nそもそも Go は<code>string</code>を作る際にデコードを行わないからです。</li>\n<li><code>len(s)</code>は<code>s</code>の文字列のバイナリ列としての長さを返します。<strong>文字の数ではない</strong>の注意して下さい。</li>\n<li><a href=\"https://golang.org/ref/spec#Source_code_representation\">Go のソースコードは必ず UTF-8 でなくてはならない</a>ので、\nソースコード中に文字列リテラルとして定義された文字列は UTF-8 の文字列です。</li>\n<li><a href=\"https://blog.golang.org/strings#TOC_6.\">string に対する range-loop(for range)の場合だけ特別に文字列が UTF-8 としてデコードされて\"一文字\"ずつ処理される</a>という少し歪な仕様になっている</li>\n<li><a href=\"https://play.golang.org/p/KS0JzQ-T8m\">A sample on Go Playground</a></li>\n</ul>\n<h2 id=\"継承がない\"><a href=\"#%E7%B6%99%E6%89%BF%E3%81%8C%E3%81%AA%E3%81%84\" aria-label=\"継承がない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>継承がない</h2>\n<p><a href=\"https://golang.org/doc/faq#inheritance\">Go には継承はありません</a>。\n<a href=\"https://en.wikipedia.org/wiki/Composition_over_inheritance\">そもそも継承はプログラミング言語にあまり必要ない機能だと思います</a>。\n継承が本当に有益なこともありますが、経験上大半のケースでは設計を手抜きするために継承が使われていて、結果長い目で見た際の readability や maintainability が著しく劣化してしまっていることが多いと思います。<a href=\"https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87\">リスコフの置換原則</a>のような基本的な原則が守られておらず(そもそも多くの人は名前すら知らない)、単に一部のコードをクラス間で共有するために継承が使われていて可読性が著しく低いコードもよく目にします。\nそのため、そもそもプログラミング言語が継承をサポートしないというのは良いことなのかなと思います。\nたまに継承が非常に有益なのも分かりますが。</p>\n<p><a href=\"https://golang.org/doc/effective_go.html#embedding\">Embedding</a>という機能で複数の型を合成することはできます。多重継承に少し似ていますね。</p>\n<h2 id=\"generics-がない\"><a href=\"#generics-%E3%81%8C%E3%81%AA%E3%81%84\" aria-label=\"generics がない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generics がない</h2>\n<p><a href=\"https://golang.org/doc/faq#generics\">Go には Generics はありません</a>。\n<a href=\"https://docs.oracle.com/javase/tutorial/java/generics/types.html\">Java の Generic Types</a>とか<a href=\"https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)\">C++のテンプレート</a>で書けるようなことは Go では書けません。\nただ配列(スライス), map については特別に言語でサポートされているので Java や C++で総称型を使うケースの大半はカバーされるとは思います。</p>\n<h2 id=\"goroutine-は-gc-されない\"><a href=\"#goroutine-%E3%81%AF-gc-%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84\" aria-label=\"goroutine は gc されない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>goroutine は GC されない</h2>\n<p><a href=\"https://groups.google.com/d/msg/golang-nuts/uiySuH8_3Y4/nvZoN7l0PxgJ\">goroutine はガーベッジコレクションの対象ではありません</a>。\ngoroutine は GC されないので、<code>go</code>で起動した関数は必ず終了するように気をつけてプログラムを書きましょう。Java や Python の実行中のスレッドが GC に回収されないのと同じですね、自然な仕様だと思います。ただ goroutine は割りと気軽に作成できてしまうので、うっかり新しい goroutine も GC のルートになることを忘れてしまうかも。</p>\n<p>またこの制約のため Go で新しい読み込み専用 channel だけを返す関数というのは呼び出し側が channel からデータ最後まで読み込まないとメモリリークが発生する危険性があります。\n例えば標準ライブラリの time.Tick はとても便利ですが<a href=\"https://golang.org/pkg/time/#Tick\">リークします(「<em>it \"leaks\".</em>」)</a>。\nそのため、次に述べるように Python の yield に相当することを実現するのに channel と goroutine は使わないほうがよいでしょう。</p>\n<h2 id=\"goroutine-は-generator-yield-の実装には使えない\"><a href=\"#goroutine-%E3%81%AF-generator-yield-%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%AF%E4%BD%BF%E3%81%88%E3%81%AA%E3%81%84\" aria-label=\"goroutine は generator yield の実装には使えない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>goroutine は generator (yield) の実装には使えない</h2>\n<p>Go 言語には<a href=\"https://docs.python.org/2/reference/simple_stmts.html#the-yield-statement\">Python の yield</a>に相当する機能はありません。ただ goroutine と channel を組み合わせれば yield に相当することができるのではと思うかもしれません(<a href=\"https://play.golang.org/p/AeXaSlCuFc\">Go Playground</a>)。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">squareGenerator</span><span class=\"token punctuation\">(</span>n <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n\tch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n\t\t\tch <span class=\"token operator\">&lt;-</span> i <span class=\"token operator\">*</span> i\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> ch\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> <span class=\"token function\">squareGenerator</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> i <span class=\"token operator\">></span> <span class=\"token number\">100</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">break</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>このコードは意図した通り 1, 4, 9...,81, 100 を出力します。ただこのやり方には</p>\n<ul>\n<li>channel は比較的(Go にしては)遅いのでパフォーマンスが低下する</li>\n<li>goroutine が GC されないので、channel が最後まで読み込まれないとリークする</li>\n</ul>\n<p>という 2 つの問題があります。\nまず channel は Go の他の要素に比べるとかなり低速です。channel を通じて channel の書き込み側の goroutine と読み込み側の goroutine の間でコンテキストスイッチを行うのは、<a href=\"http://ja.stackoverflow.com/questions/2970/go%E3%81%A7%E3%82%B3%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3%E3%82%92%E5%86%8D%E7%8F%BE%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95\">関数呼び出しなどに比べると数十倍から百倍ぐらい時間がかかります</a>(Go 1.5 時点)。</p>\n<p>また上に書いたように、実行中の goroutine は Java や Python のスレッドと同じで<a href=\"http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html\">GC のルート</a>になります。channel への書き込みでブロックされて停止中の goroutine も GC の対象ではありません(少なくとも 1.5 時点では)。そのため、generator が返した channel が最後まで呼び出されないと channel と goroutine がリークすることになります。</p>\n<h2 id=\"例外が推奨されない\"><a href=\"#%E4%BE%8B%E5%A4%96%E3%81%8C%E6%8E%A8%E5%A5%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84\" aria-label=\"例外が推奨されない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例外が(推奨され)ない</h2>\n<p><a href=\"https://golang.org/doc/faq#exceptions\">Go 言語の FAQ にあるように、Go には例外がありません</a>。panic, recover で例外と同じようなことはできますが、Java の例外のように気軽に使ってはなりません。個人的にはこの FAQ にかかれていることには概ね同意します。\n例外で返されたエラーを <code>try {...} catch (Exception e) {...}</code> みたいに処理しないといけないのは無意味に複雑なように思います。\nそれだけならよいですが、例外が発生するとコードが想定外の順序で実行されて困ったり、何故かこのコードが実行されないなと思ったら、その前に例外で大域脱出していて、しかもその例外が予想外のところで catch され握りつぶされていたり、と例外を大規模なプロジェクトの中で正しく扱うのは中々に困難だと思います。\nGo の例外は極力使わず、エラーを値として扱うポリシーはよいもの(特に大規模なプロジェクトで、エラーハンドリングが大切なプロジェクトでは)だと思います。</p>\n<p>ただ一方で、ちょっとした使い捨ての便利ツールを書く場合や、とりあえずプロトタイプで正常系だけ書きたい時、\nあるいは異常が発生したらプログラムを停止してしまって良いような起動時の初期化処理を書く時には、正直 Go のエラーハンドリングはかなり面倒くさいです。\nこういうタイプのコードでは外部ライブラリの呼び出しやファイル、データベースなどの外部リソースへのアクセスが大きな割合を占めます。そして、そうした処理はほとんどの場合 error が発生しうるのでそれぞれの処理に対してエラーハンドリングを行う必要があります。\n場合によってはコードのかなりの割合の行が</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> err\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>の繰り返しで占められてしまうこともあるでしょう。これに対しては根本的な解決策はないように思います。エラーが発生した場合はエラーメッセージを出力して処理を中断してしまって問題ない</p>\n<ul>\n<li>使い捨てあるいは内部ツールで開発者・利用者の数が数人でエラーハンドリングがあまり重要ではない時</li>\n<li>正常系だけとりあえずプロトタイプしたい時</li>\n</ul>\n<p>には例外の方が便利であり、正直 Go 言語ではあまり効率的にコードが書けないような気がします。個人的にはそういう用途には Python などを使うのが正しい解決策のように思えます。何でも Go で書く必要はないのですから。</p>\n<h2 id=\"繰り返す-if-err--nil-return-err\"><a href=\"#%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%99-if-err--nil-return-err\" aria-label=\"繰り返す if err  nil return err permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>繰り返す if err != nil {return err}</h2>\n<p>Go では例外が推奨されずエラー処理を常にきちんと書かなくてはならないので、Go でプログラムを書いていると</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> err\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> err\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ...</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> err\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ....</span></code></pre></div>\n<p>のように <code>if err != nil</code> によるエラーハンドリングを繰り返し繰り返し書かなくてはならないことがあります。\n<a href=\"https://blog.golang.org/errors-are-values\">Go Blog</a>には<code>if err != nil { return err }</code>のパターンはあまり出現しない(once per page or two)と書かれていますが、\nプログラムのタイプによっては(例えばいろいろな外部リソースや外部ライブラリをつなぐようなコード)かなりの頻度で <code>if err != nil</code> を書かざるを得ないことがあるような気がします。\n<code>if err != nil</code> を入力するショートカット定義したほうがいいんじゃないのという気分になることがたまにあります。</p>\n<h3 id=\"解決策\"><a href=\"#%E8%A7%A3%E6%B1%BA%E7%AD%96\" aria-label=\"解決策 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解決策</h3>\n<p><code>// ...</code> の部分のコードが同じ処理の繰り返しであれば<a href=\"https://blog.golang.org/errors-are-values\">前述の Go Blog</a>に書かれているように <code>if err != nil</code> の繰り返しを避けることが出来ます。<code>if err != nil</code>が繰り返しているなと思ったら、そもそも<code>if err != nil</code>以外の部分も繰り返しになっていないか、繰り返している処理をひとまとめにできないかを考えてみるべきでしょう。</p>\n<p>一方で、このテクニックが利用できるのは<code>...</code>の部分の処理が同じ型の処理の組み合わせでコードをまとめられる場合に限られます。そもそもコードが一定以上繰り返していたらまとめたほうが良いというのは、特に<code>if err != nil</code>とは関係なく行なうべきことでしょう。Go だと関数内の内部で更に関数を定義できるので、関数の一部の処理を気軽にまとめることができます、すばらしいことです。ただ<code>// ...</code>の処理に共通点があまりなく綺麗にまとめることができない場合は、<code>if err != nil</code> の繰り返しは我慢する以外によい解決策はないようです。</p>\n<h2 id=\"return-nil-err-→-この-error-どこで発生したの？\"><a href=\"#return-nil-err-%E2%86%92-%E3%81%93%E3%81%AE-error-%E3%81%A9%E3%81%93%E3%81%A7%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F%E3%81%AE%EF%BC%9F\" aria-label=\"return nil err → この error どこで発生したの？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>return nil, err → この error どこで発生したの？</h2>\n<p>Go ではエラーハンドリングをきちんと書かなくてはなりません。とはいえ、きちんと書くと言ってもエラーが発生したら単に処理を中断してエラーを呼び出し元に返すことでエラー処理を呼び出し元に丸投げしてしまうことが多いでしょう。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> err\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>そして最後に一番外側の処理でエラーを出力します</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// ...</span>\n\tresult<span class=\"token punctuation\">,</span> err <span class=\"token operator\">!=</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\tlog<span class=\"token punctuation\">.</span><span class=\"token function\">Fatal</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>プログラムを走らせたらエラーが発生してエラーが出力されました。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Invalid Argument</code></pre></div>\n<p>あれ...このエラーどこで発生したの...</p>\n<p>Go のエラーはただの値なので Java や Python の例外などと違ってスタックトレースを含みません。\nGo のエラーには、そのエラーがどこで発生したかというコンテキストが自動的には含まれないのです。\nそのため、エラーハンドリングを呼び出し元に任せるからといって error を呼び出し元に何も考えずに返していると最終的にそのエラーがどこで発生したのかが分からなくなってしまいます。\nなので、error を呼び出しに返すときは手動でエラーのコンテキストを残してあげましょう。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Errorf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Some context: %v\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>これでエラーがどこで発生したのかが分かるようになります。ただこういうことしてると実は例外で良かったんじゃないかという気分にもなりますが。</p>\n<h2 id=\"関数より狭いスコープで-defer\"><a href=\"#%E9%96%A2%E6%95%B0%E3%82%88%E3%82%8A%E7%8B%AD%E3%81%84%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%A7-defer\" aria-label=\"関数より狭いスコープで defer permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>関数より狭いスコープで defer</h2>\n<p>C#の using, Python の with のように他の人気のある言語ではあるスコープから処理が抜ける際に、リソースの解放処理を確実に実行するための機能がサポートされています。<a href=\"http://www.ne.jp/asahi/hishidama/home/tech/java/statement.html#try_with_resources_statement\">Java でも 1.7 から try-with-resources</a>がサポートされています。\nGo ではそういった解放処理は<code>defer</code>を使って行います。\nただ C#の using, Python の with, Java の try-with-resources と違って Go の<code>defer</code>は一定のスコープを抜けた時ではなく、関数が終了する際に確実に指定した処理を実行する仕組みです。\nそのため、次のようなコードを書いても<code>r.Close()</code>が実行されるのは <code>if condition</code>の if 文のブロックが終了した時ではなく<code>myFunc</code>全体が終了した時になってしまいます。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">myFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> err <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// ...</span>\n\tr<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">Open</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> err\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">defer</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">Close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tdata<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> <span class=\"token function\">readDataFromReader</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 実際にはもう少し複雑な処理</span>\n\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> err\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// この時点で r.Close()を本当は呼びたいが、myFunc の終了まで呼び出されない。</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"struct-と-cjava-のクラスとの違い\"><a href=\"#struct-%E3%81%A8-cjava-%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84\" aria-label=\"struct と cjava のクラスとの違い permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>struct と C++/Java のクラスとの違い</h2>\n<p>これもはまりどころというよりは、Go でコードを書く上で理解しておきたいポイントの整理ですが。\nGo の struct と C++/Java のクラスの、コードを書く上での理解しておくべき大きな違いは、struct (class) の初期化の方法の違い(コンストラクタがない)から来ます。</p>\n<h3 id=\"コンストラクタがない\"><a href=\"#%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%81%8C%E3%81%AA%E3%81%84\" aria-label=\"コンストラクタがない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>コンストラクタがない</h3>\n<p>Go にはコンストラクタがありません。Go では C++、Java のコンストラクタに相当する関数を単なる関数として定義します。ただこれは定義方法が C++, Java と違うというだけで、実際にコードを書くときには大した違いはないように思います。</p>\n<p>Go では struct は通常</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> mydata MyData\nmydata <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>MyData <span class=\"token punctuation\">{</span>\n\tX<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n\tY<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>のように<a href=\"https://golang.org/ref/spec#Composite_literals\">StructType{name: value,...}</a>で初期化します。{name: value}が省略された場合はゼロ初期化されます。Go にはコンストラクタは存在しません。Go である struct の初期化関数を用意したい場合には、パッケージに生成用の関数を用意します。通常、関数の名前は New+struct 名(+付加情報)のようになります。例えば、bytes.Buffer には []byte から bytes.Buffer を生成する bytes.NewBuffer と string から bytes.Buffer を生成する bytes.NewBufferString が用意されています。</p>\n<h3 id=\"ゼロ初期化が避けられない\"><a href=\"#%E3%82%BC%E3%83%AD%E5%88%9D%E6%9C%9F%E5%8C%96%E3%81%8C%E9%81%BF%E3%81%91%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84\" aria-label=\"ゼロ初期化が避けられない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ゼロ初期化が避けられない</h3>\n<p>Go では、struct のメンバー変数をパッケージ外に非公開にすることができます。非公開になっているメンバーは他のパッケージから直接編集することはできません。ただし、struct がパッケージ外に公開されている場合、例え全ての変数が非公開だったとしても</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> mydata MyData</code></pre></div>\n<p>のように書かれてしまうと、MyData の中身は全てゼロ値で初期化されてしまいます。C++/や Java ではコンストラクタに書かれているようにしか非公開のメンバーは変更できないので、メンバーがどのように初期化されるかは明示することができます。しかし Go ではそのようなことはできません。struct が外部に公開されるのならば struct は全てがゼロ初期化された場合にも正しく動くように常に設計しなくてはならないのです。</p>\n<h3 id=\"コピーされるのが避けられない\"><a href=\"#%E3%82%B3%E3%83%94%E3%83%BC%E3%81%95%E3%82%8C%E3%82%8B%E3%81%AE%E3%81%8C%E9%81%BF%E3%81%91%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84\" aria-label=\"コピーされるのが避けられない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>コピーされるのが避けられない</h3>\n<p>Go では C++のコピーコンストラクタのような仕組みはないので、struct のコピーを防止することは不可能です。公開されている struct は他のパッケージのコードで自由にコピーができてしまいます。実は Go ははじめのころは非公開のメンバーがある struct はパッケージ外部ではコピーすることはできませんでした。しかし、<a href=\"https://go.googlesource.com/go/+/d03611f628c65321b572ab0d4ce85cc61b759fc6\">2011 年に仕様が変更</a>されて非公開のメンバーが存在してもコピー可能なようになりました。</p>\n<p>そのためパッケージ外部に公開されている struct はコピーされても不都合が(あまり)起こらないようにすべきです。コピーされると非常に不都合な struct は interface だけを公開して実際の実装である struct を隠すか、あるいはコピーされたくないフィールドを別の struct に分離して公開する struct ではその struct へのポインタを保持するようにします。\n例えば<a href=\"https://golang.org/pkg/os/#File\">標準ライブラリの os.File</a>は、ソースコードを見るとファイルディスクリプタなどを管理する private な <code>os.file struct</code> へのポインタとなっています。これはファイルの実体に対応する構造体<code>os.file</code>がコピーされて同じファイルが 2 回閉じられたりするようなことが起こらないように配慮された結果です。</p>\n<p>ちなみに os.File は<code>*os.file</code>を 1 つ持つだけの<code>struct</code>ですが、これを<code>type File *file</code>としては意味がありません。なぜなら<code>type File *file</code>としてしまうと、<code>os.File</code>はポインタなので例え<code>os.file</code>が非公開だとしても<code>*</code>演算でポインタの実体が参照できてしまい、<code>*file0 = *file1</code>のように書くことで<code>os.file</code>のコピーがパッケージ外部でもできてしまうからです。</p>\n<h2 id=\"キャストという概念がない\"><a href=\"#%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88%E3%81%A8%E3%81%84%E3%81%86%E6%A6%82%E5%BF%B5%E3%81%8C%E3%81%AA%E3%81%84\" aria-label=\"キャストという概念がない permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>キャストという概念がない</h2>\n<p>Go (golang) にはキャストがありません。そもそも C++や Java のキャストは</p>\n<ul>\n<li>プリミティブ型のデータ変換(int→float)</li>\n<li>親クラス、インターフェイスへの参照をサブクラス参照へと型を変更(Object→String)</li>\n</ul>\n<p>という 2 つの全く異なる処理が「キャスト」という概念に統合されてしまっています。\nそのため<a href=\"http://www.yunabe.jp/docs/cpp_casts.html\">C++では旧来のキャストに加えて 4 つのキャスト演算がサポートされたりしています</a>。\nGo ではこの２つの処理は全く異なるシンタックスで扱われます。そもそも全く異なる処理なのだから、Go のやり方のほうが正しいです。</p>\n<ul>\n<li>\n<p>プリミティブ型のデータ変換</p>\n<ul>\n<li><code>int</code>→<code>float</code>などのプリミティブ型間のデータ変換には <code>newtype(val)</code> を使います。</li>\n<li><code>int64(f)</code>, <code>float64(i)</code> など</li>\n<li><code>[]byte</code>と<code>string</code>の変換も非常によく使います。<code>[]byte(str)</code>, <code>string(binary)</code></li>\n</ul>\n</li>\n<li>\n<p>interface から実体を取り出す</p>\n<ul>\n<li><code>obj.(subType)</code>という少し風変わりなシンタックスで処理します。</li>\n<li>Java で親クラスからサブクラスに、インターフェイスからサブインターフェイスに変換するのに相当する処理です。\ninterface からその実体の struct や struct のポインタ、あるいはより詳細な interface に変換します。</li>\n<li>このシンタックスは 3 通りの使い方があります。</li>\n<li><code>s := obj.(*myStruct)</code></li>\n<li>interface <code>obj</code>を<code>*myStruct</code>として扱えるかをチェックし、可能な場合は<code>*myStruct</code>を取り出します。\nそうでない場合は<strong>panic</strong>します。</li>\n<li><code>s, ok := obj.(*myStruct)</code></li>\n<li>上記とほぼ同じですが、panic する代わりにチェック結果を<code>bool</code>値の<code>ok</code>に格納します。<code>ok</code>であって<code>error</code>でないので注意。</li>\n<li>失敗した場合は、<code>s</code>には<code>nil</code>などが入ります。</li>\n<li><a href=\"https://golang.org/doc/effective_go.html#type_switch\">type switch</a></li>\n<li><code>s, ok := obj.(subType)</code>を複数の型に対して行って条件分岐するのを簡潔に記述するための特殊な構文が用意されています。</li>\n<li><a href=\"https://play.golang.org/p/7TQNQZxEbZ\">An example on Go Playground</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"型が後置\"><a href=\"#%E5%9E%8B%E3%81%8C%E5%BE%8C%E7%BD%AE\" aria-label=\"型が後置 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>型が後置</h2>\n<p>これは慣れです。C, Java 系をメインで使っている多くのプログラマには最初は違和感があります。でも使っていれば割とどちらでもいいなという気分になります。\nとはいえ後置の言語と前置の言語両方書いてるとたまに混乱します。</p>\n<h2 id=\"10-が浮動小数点型にならない時がある\"><a href=\"#10-%E3%81%8C%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E5%9E%8B%E3%81%AB%E3%81%AA%E3%82%89%E3%81%AA%E3%81%84%E6%99%82%E3%81%8C%E3%81%82%E3%82%8B\" aria-label=\"10 が浮動小数点型にならない時がある permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.0 が浮動小数点型にならない(時がある)</h2>\n<p><a href=\"https://play.golang.org/p/JjB2WDohT3\">https://play.golang.org/p/JjB2WDohT3</a></p>\n<h2 id=\"名前が\"><a href=\"#%E5%90%8D%E5%89%8D%E3%81%8C\" aria-label=\"名前が permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>名前が...</h2>\n<p>何でこんな検索しにくい名前なのだろうな...結果 golang で検索する羽目になるなら最初から golang という名前だったらまだ良かったのにと思います。</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/docs/golang_pitfall.html/#interface-%E3%81%A8-nil-go-%E3%81%AE-interface-%E3%81%AF%E5%8D%98%E3%81%AA%E3%82%8B%E5%8F%82%E7%85%A7%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84\">interface と nil (Go の interface は単なる参照ではない)</a></p>\n<ul>\n<li><a href=\"/docs/golang_pitfall.html/#%E6%96%87%E7%8C%AE\">文献</a></li>\n</ul>\n</li>\n<li><a href=\"/docs/golang_pitfall.html/#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E5%86%85%E3%81%A7%E3%83%AC%E3%82%B7%E3%83%BC%E3%83%90this-self%E3%81%8C-nil-%E3%81%A7%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%82%92%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AB%E6%84%8F%E5%91%B3%E3%81%8C%E3%81%82%E3%82%8B\">メソッド内でレシーバ(this, self)が nil でないことをチェックすることに意味がある</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#error-%E3%81%97%E3%81%8B%E8%BF%94%E3%82%8A%E5%80%A4%E3%81%8C%E3%81%AA%E3%81%84%E9%96%A2%E6%95%B0%E3%81%A7-error-%E3%82%92%E5%87%A6%E7%90%86%E3%81%97%E5%BF%98%E3%82%8C%E3%82%8B\">error しか返り値がない関数で error を処理し忘れる</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#defer-%E3%81%AE%E4%B8%AD%E3%81%A7%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F-error-%E3%82%92%E5%87%A6%E7%90%86%E3%81%97%E5%BF%98%E3%82%8C%E3%82%8B\">defer の中で発生した error を処理し忘れる</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E5%9F%BA%E6%9C%AC%E5%9E%8B%E3%81%8C%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%92%E6%8C%81%E3%81%9F%E3%81%AA%E3%81%84\">基本型がメソッドを持たない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#string-%E3%81%8C%E5%8D%98%E3%81%AA%E3%82%8B%E3%83%90%E3%82%A4%E3%83%88%E5%88%97\">string が単なるバイト列</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E7%B6%99%E6%89%BF%E3%81%8C%E3%81%AA%E3%81%84\">継承がない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#generics-%E3%81%8C%E3%81%AA%E3%81%84\">Generics がない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#goroutine-%E3%81%AF-gc-%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84\">goroutine は GC されない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#goroutine-%E3%81%AF-generator-yield-%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%AF%E4%BD%BF%E3%81%88%E3%81%AA%E3%81%84\">goroutine は generator (yield) の実装には使えない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E4%BE%8B%E5%A4%96%E3%81%8C%E6%8E%A8%E5%A5%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84\">例外が(推奨され)ない</a></li>\n<li>\n<p><a href=\"/docs/golang_pitfall.html/#%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%99-if-err--nil-return-err\">繰り返す if err != nil {return err}</a></p>\n<ul>\n<li><a href=\"/docs/golang_pitfall.html/#%E8%A7%A3%E6%B1%BA%E7%AD%96\">解決策</a></li>\n</ul>\n</li>\n<li><a href=\"/docs/golang_pitfall.html/#return-nil-err-%E2%86%92-%E3%81%93%E3%81%AE-error-%E3%81%A9%E3%81%93%E3%81%A7%E7%99%BA%E7%94%9F%E3%81%97%E3%81%9F%E3%81%AE%EF%BC%9F\">return nil, err → この error どこで発生したの？</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E9%96%A2%E6%95%B0%E3%82%88%E3%82%8A%E7%8B%AD%E3%81%84%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%A7-defer\">関数より狭いスコープで defer</a></li>\n<li>\n<p><a href=\"/docs/golang_pitfall.html/#struct-%E3%81%A8-cjava-%E3%81%AE%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%A8%E3%81%AE%E9%81%95%E3%81%84\">struct と C++/Java のクラスとの違い</a></p>\n<ul>\n<li><a href=\"/docs/golang_pitfall.html/#%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%81%8C%E3%81%AA%E3%81%84\">コンストラクタがない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E3%82%BC%E3%83%AD%E5%88%9D%E6%9C%9F%E5%8C%96%E3%81%8C%E9%81%BF%E3%81%91%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84\">ゼロ初期化が避けられない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E3%82%B3%E3%83%94%E3%83%BC%E3%81%95%E3%82%8C%E3%82%8B%E3%81%AE%E3%81%8C%E9%81%BF%E3%81%91%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84\">コピーされるのが避けられない</a></li>\n</ul>\n</li>\n<li><a href=\"/docs/golang_pitfall.html/#%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88%E3%81%A8%E3%81%84%E3%81%86%E6%A6%82%E5%BF%B5%E3%81%8C%E3%81%AA%E3%81%84\">キャストという概念がない</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E5%9E%8B%E3%81%8C%E5%BE%8C%E7%BD%AE\">型が後置</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#10-%E3%81%8C%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B0%E7%82%B9%E5%9E%8B%E3%81%AB%E3%81%AA%E3%82%89%E3%81%AA%E3%81%84%E6%99%82%E3%81%8C%E3%81%82%E3%82%8B\">1.0 が浮動小数点型にならない(時がある)</a></li>\n<li><a href=\"/docs/golang_pitfall.html/#%E5%90%8D%E5%89%8D%E3%81%8C\">名前が...</a></li>\n</ul>","frontmatter":{"title":"Go 言語(Golang) はまりどころと解決策","lastmod":"2017-04-14T00:00:00.000Z","enable_toc":true},"fields":{"slug":"/docs/golang_pitfall.html"}},"site":{"siteMetadata":{"title":"yunabe.jp"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/docs/golang_pitfall.html"}}}