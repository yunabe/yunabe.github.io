<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Go言語(Golang) はまりどころと解決策</title>
  <meta name="description" content="">
  <meta property="fb:admins" content="yunabe">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://www.yunabe.jp/docs/golang_pitfall.html">
  <link rel="alternate" type="application/rss+xml" title="" href="http://www.yunabe.jp/feed.xml">
  <script>
    if(location.host=='www.yunabe.jp'){
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-19477574-2', 'yunabe.jp');
    ga('require', 'displayfeatures');
    ga('send', 'pageview');
    }
  </script>
</head>


  <body>
    <div class="page-content">
      <div class="wrapper">
        <header class="post-header">
          <h1 class="post-title" itemprop="name headline">Go言語(Golang) はまりどころと解決策</h1>
          <p class="post-meta"><time datetime="2015-11-04T00:00:00+09:00" itemprop="datePublished">更新 Nov 4, 2015</time></p>
        </header>
        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <h1 id="section">目次</h1>
<p><a href="https://golang.org/ref/spec">Goの言語仕様</a>はシンプルで他の言語に比べてはまりどころが少なくて学習コストが小さめな言語のように思います。
しかし、それでもはまるところがないわけではないので、自分がはまって時間を無駄にしてしまったことを書き留めておきます。</p>

<ul id="markdown-toc">
  <li><a href="#section">目次</a></li>
  <li><a href="#interface-nil-gointerface">interface とnil (Goのinterfaceは単なる参照ではない)</a>    <ul>
      <li><a href="#section-1">文献</a></li>
    </ul>
  </li>
  <li><a href="#errorerror">errorしか引数がない関数でerrorを処理し忘れる</a></li>
  <li><a href="#section-2">基本型がメソッドを持たない</a></li>
  <li><a href="#string">stringが単なるバイト列</a></li>
  <li><a href="#section-3">継承がない</a></li>
  <li><a href="#generics">Genericsがない</a></li>
  <li><a href="#goroutine-gc">goroutine はGCされない</a></li>
  <li><a href="#goroutinegenerator-yield-">goroutineはgenerator (yield) の実装には使えない</a></li>
  <li><a href="#section-4">例外が(推奨され)ない</a></li>
  <li><a href="#if-err--nil-return-err">繰り返す if err != nil {return err}</a>    <ul>
      <li><a href="#section-5">解決策</a></li>
    </ul>
  </li>
  <li><a href="#return-nil-err--error">return nil, err → このerrorどこで発生したの？</a></li>
  <li><a href="#defer">関数より狭いスコープで defer</a></li>
  <li><a href="#section-6">1.0 が浮動小数点型にならない(時がある)</a></li>
  <li><a href="#section-7">型が後置</a></li>
  <li><a href="#section-8">名前が…</a></li>
</ul>

<h1 id="interface-nil-gointerface">interface とnil (Goのinterfaceは単なる参照ではない)</h1>
<p>JavaやC#あるいはC++の経験があり、ある程度クラスの内部構造への理解がある人はGoのinterfaceの実体もデータへの参照だと考えると思います。
しかし実はそれは正しくありません。Goのinterfaceの実体は参照(ポインタ)ではありません。<a href="http://research.swtch.com/interfaces">Goのinterfaceの実体は参照と型情報のペアです</a>。</p>

<p>さてこの内部構造の違いがGoにどういった影響をもたらすのでしょうか。実はこの内部構造の違い、意外と言語の挙動にはあまり大きな影響を与えません。そのためこの点を理解していなくてもGoでプログラムを書けてしまいます。ただしnilを扱う場合にはGoは予想外の挙動をします。</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">myError</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">message</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">e</span><span class="x"> </span><span class="o">*</span><span class="n">myError</span><span class="p">)</span><span class="x"> </span><span class="n">Error</span><span class="p">()</span><span class="x"> </span><span class="kt">string</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">e</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="s">"myError: &lt;nil&gt;"</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="s">"myError: "</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">myFunc</span><span class="p">(</span><span class="n">x</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">*</span><span class="n">myError</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">x</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">myError</span><span class="p">{</span><span class="x">
            </span><span class="n">message</span><span class="o">:</span><span class="x"> </span><span class="s">"x should be positive or zero."</span><span class="p">,</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">myFunc</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"err is NOT nil."</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"err is nil."</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span></code></pre></div>

<p><a href="https://play.golang.org/p/ClzTEOs_P-">上のコード(Go Playground)</a>では、myFuncは<code>x &gt;= 0</code>の時には<code>var err *myError</code>の初期値<code>nil</code>を返すので、mainの最初の<code>fmt.Println(err)</code>は<code>myError: &lt;nil&gt;</code>を出力します。そして、次のif-elseはerrがnilだから”err is nil.”が表示されると思うかもしれません。JavaやC++ならそうなります。しかしGoでは”err is NOT nil”が表示されます。</p>

<p>何故こうなるのかは、interfaceが型と値への参照のペアであること点を踏まえた上で、errのValueとTypeを<code>reflect.ValueOf</code>, <code>reflect.TypeOf</code>を使って表示してみると明らかです。
err のTypeとValueを表示してみると、Typeが<code>*main.myError</code>で値がValueが<code>&lt;nil&gt;</code>であることが分かります。errの”値”は<code>nil</code>ですがerrは型情報を保持しているのです。
型を持っているinterfaceはValueが<code>nil</code>でも<code>nil</code>ではないのです。</p>

<pre><code>---- err ----
is nil: false
Type: *main.myError
Value: &lt;nil&gt;
---- trueNil ----
is nil: true
Type: &lt;nil&gt;
Value: &lt;invalid reflect.Value&gt;
</code></pre>

<p>ちなみにこれは<a href="https://golang.org/doc/faq#nil_error">Frequently Asked Questions (FAQ)</a>に<a href="https://github.com/golang/go/commit/1e0f97ac6544ab3b7cf76e9c9d62e8c2a60bcdb6">2012年から</a>書いてある問題です。
よくドキュメントを読まずに色々はまって時間をつぶすす前に(自分は数時間つぶしました)、まずFAQくらいは目を通しておいたほうがよいですね。</p>

<h2 id="section-1">文献</h2>
<ul>
  <li><a href="https://golang.org/doc/faq#nil_error">Why is my nil error value not equal to nil?</a></li>
  <li><a href="http://blog.golang.org/laws-of-reflection">The Laws of Reflection - The Go Blog</a></li>
  <li><a href="http://research.swtch.com/interfaces">Go Data Structures: Interfaces</a></li>
</ul>

<h1 id="errorerror">errorしか引数がない関数でerrorを処理し忘れる</h1>
<p>Goではエラーは通常、最後の返り値として呼び出し元に返されます。関数が何か重要な値を返す場合であれば、<code>_</code>を利用しないかぎりはerrorは無視できないのでerrorを処理し忘れることはあまりないと思います。ただ<a href="https://golang.org/pkg/encoding/json/#Unmarshal">json.Unmarshal</a>のようなerror以外に重要な情報を返さない関数は、エラー以外に返り値がないからといって、うっかり返り値を受け取るのを忘れるとerrorが失われます。</p>

<iframe src="https://play.golang.org/p/E9UM39VxQx" frameborder="0" style="width: 100%; height: 400px"><a href="https://play.golang.org/p/E9UM39VxQx">see this code in play.golang.org</a></iframe>

<p>例えば上のコードは<code>"not json"</code>はjsonとしてパース出来ないのでエラーが発生しますが、コンパイル時にはエラーが無視されていることは検出されません。これに関しては気をつける以外に解決策はないと思います。</p>

<h1 id="section-2">基本型がメソッドを持たない</h1>
<p><a href="https://golang.org/doc/faq#methods_on_basics">例えばstringがlenをメソッドとして持ちません</a>。これは<a href="https://msdn.microsoft.com/ja-jp/library/system.int32.aspx">C#とかではintですらメソッドを持つ</a>のと真逆を行くように思える。
Goのインターフェースで宣言されているメソッドが実装されていれば、そのインターフェースを実装していることになるという仕様と関係している？</p>

<h1 id="string">stringが単なるバイト列</h1>
<p>Java, C#やPython3などのモダンな言語では文字列(string)はUnicode文字の列ですが、<a href="https://blog.golang.org/strings">Go言語のstringは単なるimmutable(書き換え不可能)なバイト列に過ぎません(In Go, a string is in effect a read-only slice of bytes.)</a>。Goのstringは中身がUTF-8でエンコードされた文字列かも知れませんし、Shift_JISでエンコードされた文字列かもしれません。</p>

<p><a href="https://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit">これは文字列をUnicodeにしたPython3</a>の真逆を行く感じで正直本当に正しいのかはよく分かりません。</p>

<ul>
  <li>Goではファイルなどから<code>string</code>を読み込む際にエンコードを指定したりはしません。
<a href="https://docs.oracle.com/javase/jp/6/api/java/io/FileReader.html">これは他の言語のようにデフォルトの文字エンコーディングで暗黙的にデコードされている</a>のではなく、
そもそもGoは<code>string</code>を作る際にデコードを行わないからです。</li>
  <li><code>len(s)</code>は<code>s</code>の文字列のバイナリ列としての長さを返します。<strong>文字の数ではない</strong>の注意して下さい。</li>
  <li><a href="https://golang.org/ref/spec#Source_code_representation">Goのソースコードは必ずUTF-8でなくてはならない</a>ので、
ソースコード中に文字列リテラルとして定義された文字列はUTF-8の文字列です。</li>
  <li><a href="https://blog.golang.org/strings#TOC_6.">stringに対するrange-loop(for range)の場合だけ特別に文字列がUTF-8としてデコードされて”一文字”ずつ処理される</a>という少し歪な仕様になっている</li>
  <li><a href="https://play.golang.org/p/KS0JzQ-T8m">A sample on Go Playground</a></li>
</ul>

<h1 id="section-3">継承がない</h1>
<p><a href="https://golang.org/doc/faq#inheritance">Goには継承はありません</a>。
<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">そもそも継承はプログラミング言語にあまり必要ない機能だと思います</a>。
継承が本当に有益なこともありますが、経験上大半のケースでは設計を手抜きするために継承が使われていて、結果長い目で見た際のreadabilityやmaintainabilityが著しく劣化してしまっているなと思うのでそもそも継承がないというのは良いことなのかなと思います。</p>

<p><a href="https://golang.org/doc/effective_go.html#embedding">Embedding</a>という機能で複数の型を合成することはできます。多重継承に少し似ていますね。</p>

<h1 id="generics">Genericsがない</h1>
<p><a href="https://golang.org/doc/faq#generics">GoにはGenericsはありません</a>。
<a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html">JavaのGeneric Types</a>とか<a href="https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)">C++のテンプレート</a>で書けるようなことはGoでは書けません。
ただ配列(スライス), mapについては特別に言語でサポートされているのでJavaやC++で総称型を使うケースの大半はカバーされるとは思います。</p>

<h1 id="goroutine-gc">goroutine はGCされない</h1>
<p><a href="https://groups.google.com/d/msg/golang-nuts/uiySuH8_3Y4/nvZoN7l0PxgJ">goroutine はガーベッジコレクションの対象ではありません</a>。
goroutineはGCされないので、<code>go</code>で起動した関数は必ず終了するように気をつけてプログラムを書きましょう。JavaやPythonの実行中のスレッドがGCに回収されないのと同じですね、自然な仕様だと思います。ただgoroutineは割りと気軽に作成できてしまうので、うっかり新しいgoroutineもGCのルートになることを忘れてしまうかも。</p>

<p>またこの制約のためGoで新しい読み込み専用channelだけを返す関数というのは呼び出し側がchannelからデータ最後まで読み込まないとメモリリークが発生する危険性があります。
例えば標準ライブラリのtime.Tickはとても便利ですが<a href="https://golang.org/pkg/time/#Tick">リークします(「<em>it “leaks”.</em>」)</a>。
そのため、次に述べるようにPythonのyieldに相当することを実現するのにchannelとgoroutineは使わないほうがよいでしょう。</p>

<h1 id="goroutinegenerator-yield-">goroutineはgenerator (yield) の実装には使えない</h1>
<p>Go言語には<a href="https://docs.python.org/2/reference/simple_stmts.html#the-yield-statement">Pythonのyield</a>に相当する機能はありません。ただgoroutineとchannelを組み合わせればyieldに相当することができるのではと思うかもしれません(<a href="https://play.golang.org/p/AeXaSlCuFc">Go Playground</a>)。</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">squareGenerator</span><span class="p">(</span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="o">&lt;-</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">ch</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">n</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">ch</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">i</span><span class="x">
        </span><span class="p">}</span><span class="x">
        </span><span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span><span class="x">
    </span><span class="p">}()</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">ch</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">squareGenerator</span><span class="p">(</span><span class="m">100</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">100</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">break</span><span class="x">
        </span><span class="p">}</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span></code></pre></div>

<p>このコードは意図した通り1, 4, 9…,81, 100を出力します。ただこのやり方には</p>

<ul>
  <li>channel は比較的(Goにしては)遅いのでパフォーマンスが低下する</li>
  <li>goroutine がGCされないので、channelが最後まで読み込まれないとリークする</li>
</ul>

<p>という2つの問題があります。
まずchannelはGoの他の要素に比べるとかなり低速です。channelを通じてchannelの書き込み側のgoroutineと読み込み側のgoroutineの間でコンテキストスイッチを行うのは、<a href="http://ja.stackoverflow.com/questions/2970/go%E3%81%A7%E3%82%B3%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3%E3%82%92%E5%86%8D%E7%8F%BE%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95">関数呼び出しなどに比べると数十倍から百倍ぐらい時間がかかります</a>(Go 1.5時点)。</p>

<p>また上に書いたように、実行中のgoroutineはJavaやPythonのスレッドと同じで<a href="http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html">GCのルート</a>になります。channelへの書き込みでブロックされて停止中のgoroutineもGCの対象ではありません(少なくとも1.5時点では)。そのため、generatorが返したchannelが最後まで呼び出されないとchannelとgoroutineがリークすることになります。</p>

<h1 id="section-4">例外が(推奨され)ない</h1>
<p><a href="https://golang.org/doc/faq#exceptions">Go言語のFAQにあるように、Goには例外がありません</a>。panic, recoverで例外と同じようなことはできますが、Javaの例外のように気軽に使ってはなりません。個人的にはこのFAQにかかれていることには概ね同意します。
例外で返されたエラーを <code>try {...} catch (Exception e) {...}</code> みたいに処理しないといけないのは無意味に複雑なように思います。
それだけならよいですが、例外が発生するとコードが想定外の順序で実行されて困ったり、何故かこのコードが実行されないなと思ったら、その前に例外で大域脱出していて、しかもその例外が予想外のところでcatchされ握りつぶされていたり、と例外を大規模なプロジェクトの中で正しく扱うのは中々に困難だと思います。
Goの例外は極力使わず、エラーを値として扱うポリシーはよいもの(特に大規模なプロジェクトで、エラーハンドリングが大切なプロジェクトでは)だと思います。</p>

<p>ただ一方で、ちょっとした使い捨ての便利ツールを書く場合や、とりあえずプロトタイプで正常系だけ書きたい時、
あるいは異常が発生したらプログラムを停止してしまって良いような起動時の初期化処理を書く時には、正直Goのエラーハンドリングはかなり面倒くさいです。
こういうタイプのコードでは外部ライブラリの呼び出しやファイル、データベースなどの外部リソースへのアクセスが大きな割合を占めます。そして、そうした処理はほとんどの場合 error が発生しうるのでそれぞれの処理に対してエラーハンドリングを行う必要があります。
場合によってはコードのかなりの割合の行が</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span></code></pre></div>

<p>の繰り返しで占められてしまうこともあるでしょう。これに対しては根本的な解決策はないように思います。エラーが発生した場合はエラーメッセージを出力して処理を中断してしまって問題ない </p>

<ul>
  <li>使い捨てあるいは内部ツールでエラーハンドリングがあまり重要ではない時</li>
  <li>正常系だけとりあえずプロトタイプしたい時</li>
</ul>

<p>には例外の方が便利であり、正直Go言語ではあまり効率的にコードが書けないような気がします。個人的にはそういう用途にはPythonなどを使うのが正しい解決策のように思えます。何でもGoで書く必要はないのですから。</p>

<h1 id="if-err--nil-return-err">繰り返す if err != nil {return err}</h1>
<p>Goでは例外が推奨されずエラー処理を常にきちんと書かなくてはならないので、Goでプログラムを書いていると</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="c">// ...</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="c">// ...</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="c">// ....</span></code></pre></div>

<p>のように <code>if err != nil</code> によるエラーハンドリングを繰り返し繰り返し書かなくてはならないことがあります。
<a href="https://blog.golang.org/errors-are-values">Go Blog</a>には<code>if err != nil { return err }</code>のパターンはあまり出現しない(once per page or two)と書かれていますが、
プログラムのタイプによっては(例えばいろいろな外部リソースや外部ライブラリをつなぐようなコード)かなりの頻度で <code>if err != nil</code> を書かざるを得ないことがあるような気がします。
<code>if err != nil</code> を入力するショートカット定義したほうがいいんじゃないのという気分になることがたまにあります。</p>

<h2 id="section-5">解決策</h2>
<p><code>// ...</code> の部分のコードが同じ処理の繰り返しであれば<a href="https://blog.golang.org/errors-are-values">前述のGo Blog</a>に書かれているように <code>if err != nil</code> の繰り返しを避けることが出来ます。<code>if err != nil</code>が繰り返しているなと思ったら、そもそも<code>if err != nil</code>以外の部分も繰り返しになっていないか、繰り返している処理をひとまとめにできないかを考えてみるべきでしょう。</p>

<p>一方で、このテクニックが利用できるのは<code>...</code>の部分の処理が同じ型の処理の組み合わせでコードをまとめられる場合に限られます。そもそもコードが一定以上繰り返していたらまとめたほうが良いというのは、特に<code>if err != nil</code>とは関係なく行なうべきことでしょう。Goだと関数内の内部で更に関数を定義できるので、関数の一部の処理を気軽にまとめることができます、すばらしいことです。ただ<code>// ...</code>の処理に共通点があまりなく綺麗にまとめることができない場合は、<code>if err != nil</code> の繰り返しは我慢する以外によい解決策はないようです。</p>

<h1 id="return-nil-err--error">return nil, err → このerrorどこで発生したの？</h1>
<p>Goではエラーハンドリングをきちんと書かなくてはなりません。とはいえ、きちんと書くと言ってもエラーが発生したら単に処理を中断してエラーを呼び出し元に返すことでエラー処理を呼び出し元に丸投げしてしまうことが多いでしょう。</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span></code></pre></div>

<p>そして最後に一番外側の処理でエラーを出力します</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="c">// ...</span><span class="x">
  </span><span class="n">result</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">doSomething</span><span class="p">()</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
  </span><span class="p">}</span><span class="x">
  </span><span class="c">// ...</span><span class="x">
</span><span class="p">}</span></code></pre></div>

<p>プログラムを走らせたらエラーが発生してエラーが出力されました。</p>

<pre><code>Invalid Argument
</code></pre>

<p>あれ…このエラーどこで発生したの…</p>

<p>Goのエラーはただの値なのでJavaやPythonの例外などと違ってスタックトレースを含みません。
Goのエラーには、そのエラーがどこで発生したかというコンテキストが自動的には含まれないのです。
そのため、エラーハンドリングを呼び出し元に任せるからといってerrorを呼び出し元に何も考えずに返していると最終的にそのエラーがどこで発生したのかが分からなくなってしまいます。
なので、errorを呼び出しに返すときは手動でエラーのコンテキストを残してあげましょう。</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"Some context: %v"</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
</span><span class="p">}</span></code></pre></div>

<p>これでエラーがどこで発生したのかが分かるようになります。ただこういうことしてると実は例外で良かったんじゃないかという気分にもなりますが。</p>

<h1 id="defer">関数より狭いスコープで defer</h1>
<p>C#のusing, Pythonのwithのように他の人気のある言語ではあるスコープから処理が抜ける際に、リソースの解放処理を確実に実行するための機能がサポートされています。<a href="http://www.ne.jp/asahi/hishidama/home/tech/java/statement.html#try_with_resources_statement">Javaでも1.7からtry-with-resources</a>がサポートされています。
Goではそういった解放処理は<code>defer</code>を使って行います。
ただC#のusing, Pythonのwith, Javaのtry-with-resourcesと違ってGoの<code>defer</code>は一定のスコープを抜けた時ではなく、関数が終了する際に確実に指定した処理を実行する仕組みです。
そのため、次のようなコードを書いても<code>r.Close()</code>が実行されるのは <code>if condition</code>のif文のブロックが終了した時ではなく<code>myFunc</code>全体が終了した時になってしまいます。</p>

<div class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">func</span><span class="x"> </span><span class="n">myFunc</span><span class="p">()</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="c">// ...</span><span class="x">
  </span><span class="n">r</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
  </span><span class="p">}</span><span class="x">
  </span><span class="k">defer</span><span class="x"> </span><span class="n">r</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">
  </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">readDataFromReader</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="x">  </span><span class="c">// 実際にはもう少し複雑な処理</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
  </span><span class="p">}</span><span class="x">
  </span><span class="c">// この時点でr.Close()を本当は呼びたいが、myFuncの終了まで呼び出されない。</span><span class="x">
</span><span class="p">}</span></code></pre></div>

<h1 id="section-6">1.0 が浮動小数点型にならない(時がある)</h1>
<p>https://play.golang.org/p/JjB2WDohT3</p>

<h1 id="section-7">型が後置</h1>

<h1 id="section-8">名前が…</h1>
<p>何でこんな検索しにくい名前なの…</p>

        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <div class="fb-comments" data-href="http://www.yunabe.jp/docs/golang_pitfall.html"  data-numposts="5"></div>
        <div style="text-align:center">
          <a href="/docs">Home</a>
        </div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  console.log(fjs);
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.3";
  fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<script src="https://apis.google.com/js/platform.js" async defer>
  {lang: 'ja'}
</script>
<script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>


  </body>

</html>
