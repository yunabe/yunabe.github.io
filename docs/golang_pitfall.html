<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Go言語(Golang) はまりどころと解決策</title>
  <meta name="description" content="">
  <meta property="fb:admins" content="yunabe">
  <meta property="fb:app_id" content="234187763701556">
  <meta property="og:url" href="http://www.yunabe.jp/docs/golang_pitfall.html">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://www.yunabe.jp/docs/golang_pitfall.html">
  <link rel="alternate" type="application/rss+xml" title="" href="http://www.yunabe.jp/feed.xml">
  <script>
    if(location.host=='www.yunabe.jp'){
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-19477574-2', 'yunabe.jp');
    ga('require', 'displayfeatures');
    ga('send', 'pageview');
    }
  </script>
</head>


  <body>
    <div class="page-content">
      <div class="wrapper">
        <header class="post-header">
          <h1 class="post-title" itemprop="name headline">Go言語(Golang) はまりどころと解決策</h1>
          <p class="post-meta"><time datetime="2016-12-15T00:00:00+09:00" itemprop="datePublished">更新 Dec 15, 2016</time></p>
        </header>
        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <h1 id="section">目次</h1>
<p><a href="https://golang.org/ref/spec">Goの言語仕様</a>はシンプルで他の言語に比べてはまりどころが少なくて学習コストが小さめな言語のように思います。しかし、それでもはまるところがないわけではないので、自分がはまって時間を無駄にしてしまったことを書き留めておきます。</p>

<p>念の為誤解のないように追記しておくと、この文書の目的はGoを批判することではなくGoがGoであるがゆえにC++/Java/Pythonなど利用者がGoを使い始めるときに困惑あるいは誤解するであろうポイントをまとめておくことで初めてGoを触る人がスムーズにGoを使い始められるようにすることです。<a href="why_golang_is_good.html">私個人はGoはバランスがとれた良い言語でだと思いますし、気に入っています</a>。</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">目次</a></li>
  <li><a href="#interface-nil-gointerface" id="markdown-toc-interface-nil-gointerface">interface とnil (Goのinterfaceは単なる参照ではない)</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">文献</a></li>
    </ul>
  </li>
  <li><a href="#this-selfnil" id="markdown-toc-this-selfnil">メソッド内でレシーバ(this, self)がnilでないことをチェックすることに意味がある</a></li>
  <li><a href="#errorerror" id="markdown-toc-errorerror">errorしか返り値がない関数でerrorを処理し忘れる</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">基本型がメソッドを持たない</a></li>
  <li><a href="#string" id="markdown-toc-string">stringが単なるバイト列</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">継承がない</a></li>
  <li><a href="#generics" id="markdown-toc-generics">Genericsがない</a></li>
  <li><a href="#goroutine-gc" id="markdown-toc-goroutine-gc">goroutine はGCされない</a></li>
  <li><a href="#goroutinegenerator-yield-" id="markdown-toc-goroutinegenerator-yield-">goroutineはgenerator (yield) の実装には使えない</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">例外が(推奨され)ない</a></li>
  <li><a href="#if-err--nil-return-err" id="markdown-toc-if-err--nil-return-err">繰り返す if err != nil {return err}</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">解決策</a></li>
    </ul>
  </li>
  <li><a href="#return-nil-err--error" id="markdown-toc-return-nil-err--error">return nil, err → このerrorどこで発生したの？</a></li>
  <li><a href="#defer" id="markdown-toc-defer">関数より狭いスコープで defer</a></li>
  <li><a href="#structcjava" id="markdown-toc-structcjava">structとC++/Javaのクラスとの違い</a>    <ul>
      <li><a href="#section-6" id="markdown-toc-section-6">コンストラクタがない</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">ゼロ初期化が避けられない</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">コピーされるのが避けられない</a></li>
    </ul>
  </li>
  <li><a href="#section-9" id="markdown-toc-section-9">キャストという概念がない</a></li>
  <li><a href="#section-10" id="markdown-toc-section-10">型が後置</a></li>
  <li><a href="#section-11" id="markdown-toc-section-11">1.0 が浮動小数点型にならない(時がある)</a></li>
  <li><a href="#section-12" id="markdown-toc-section-12">名前が…</a></li>
</ul>

<h1 id="interface-nil-gointerface">interface とnil (Goのinterfaceは単なる参照ではない)</h1>
<p>JavaやC#あるいはC++の経験があり、ある程度クラスの内部構造への理解がある人はGoのinterfaceの実体もデータへの参照だと考えると思います。
しかし実はそれは正しくありません。Goのinterfaceの実体は参照(ポインタ)ではありません。<a href="http://research.swtch.com/interfaces">Goのinterfaceの実体は参照と型情報のペアです</a>。</p>

<p>さてこの内部構造の違いがGoにどういった影響をもたらすのでしょうか。実はこの内部構造の違い、意外と言語の挙動にはあまり大きな影響を与えません。そのためこの点を理解していなくてもGoでプログラムを書けてしまいます。ただしnilを扱う場合にはGoは予想外の挙動をします。</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">myError</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">message</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">e</span><span class="x"> </span><span class="o">*</span><span class="n">myError</span><span class="p">)</span><span class="x"> </span><span class="n">Error</span><span class="p">()</span><span class="x"> </span><span class="kt">string</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">e</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="s">"myError: &lt;nil&gt;"</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="s">"myError: "</span><span class="x"> </span><span class="o">+</span><span class="x"> </span><span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">myFunc</span><span class="p">(</span><span class="n">x</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">error</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">*</span><span class="n">myError</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">x</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">err</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">myError</span><span class="p">{</span><span class="x">
            </span><span class="n">message</span><span class="o">:</span><span class="x"> </span><span class="s">"x should be positive or zero."</span><span class="p">,</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">myFunc</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"err is NOT nil."</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"err is nil."</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p><a href="https://play.golang.org/p/ClzTEOs_P-">上のコード(Go Playground)</a>では、myFuncは<code class="highlighter-rouge">x &gt;= 0</code>の時には<code class="highlighter-rouge">var err *myError</code>の初期値<code class="highlighter-rouge">nil</code>を返すので、mainの最初の<code class="highlighter-rouge">fmt.Println(err)</code>は<code class="highlighter-rouge">myError: &lt;nil&gt;</code>を出力します。そして、次のif-elseはerrがnilだから”err is nil.”が表示されると思うかもしれません。JavaやC++ならそうなります。しかしGoでは”err is NOT nil”が表示されます。</p>

<p>何故こうなるのかは、interfaceが型と値への参照のペアであること点を踏まえた上で、errのValueとTypeを<code class="highlighter-rouge">reflect.ValueOf</code>, <code class="highlighter-rouge">reflect.TypeOf</code>を使って表示してみると明らかです。
err のTypeとValueを表示してみると、Typeが<code class="highlighter-rouge">*main.myError</code>で値がValueが<code class="highlighter-rouge">&lt;nil&gt;</code>であることが分かります。errの”値”は<code class="highlighter-rouge">nil</code>ですがerrは型情報を保持しているのです。
型を持っているinterfaceはValueが<code class="highlighter-rouge">nil</code>でも<code class="highlighter-rouge">nil</code>ではないのです。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>---- err ----
is nil: false
Type: *main.myError
Value: &lt;nil&gt;
---- trueNil ----
is nil: true
Type: &lt;nil&gt;
Value: &lt;invalid reflect.Value&gt;
</code></pre>
</div>

<p>ちなみにこれは<a href="https://golang.org/doc/faq#nil_error">Frequently Asked Questions (FAQ)</a>に<a href="https://github.com/golang/go/commit/1e0f97ac6544ab3b7cf76e9c9d62e8c2a60bcdb6">2012年から</a>書いてある問題です。
よくドキュメントを読まずに色々はまって時間をつぶすす前に(自分は数時間つぶしました)、まずFAQくらいは目を通しておいたほうがよいですね。</p>

<h2 id="section-1">文献</h2>
<ul>
  <li><a href="https://golang.org/doc/faq#nil_error">Why is my nil error value not equal to nil?</a></li>
  <li><a href="http://blog.golang.org/laws-of-reflection">The Laws of Reflection - The Go Blog</a></li>
  <li><a href="http://research.swtch.com/interfaces">Go Data Structures: Interfaces</a></li>
</ul>

<h1 id="this-selfnil">メソッド内でレシーバ(this, self)がnilでないことをチェックすることに意味がある</h1>
<p>これははまりどころというより、Goだと<code class="highlighter-rouge">nil</code>に大してメソッド呼び出しを行った場合の挙動が他の人気のある言語と少し異なるので、メソッド側の書き方次第では呼び出し側の<code class="highlighter-rouge">nil</code>チェックをすこし緩和できるよという話ですが。あるいはこの点を理解していないと、呼び出し側で<code class="highlighter-rouge">nil</code>チェックしなくてなぜ大丈夫なのか困惑するという話です。</p>

<p>C++, Java, Python, JavaScript などの他の人気のある言語では</p>

<div class="highlighter-rouge"><pre class="highlight"><code>person.sayHello()
</code></pre>
</div>

<p>のようにメソッド呼び出しをする場合は(C++の場合は<code class="highlighter-rouge">.</code>でなく<code class="highlighter-rouge">-&gt;</code>)、<code class="highlighter-rouge">person</code>が<code class="highlighter-rouge">null</code>でないことを確認しなくてはなりません(C++で<code class="highlighter-rouge">sayHello</code>がnon-virtualの場合も挙動は未定義)。
しかしGoの場合は<code class="highlighter-rouge">person</code>が<code class="highlighter-rouge">struct</code>のポインタである場合には<code class="highlighter-rouge">person</code>が<code class="highlighter-rouge">nil</code>でも関数の呼び出しは問題なく行えます。
また<code class="highlighter-rouge">person</code>がインターフェイスでその値が<code class="highlighter-rouge">nil</code>で型情報が<code class="highlighter-rouge">struct</code>のポインタである(つまり上述したようにインターフェイスそのものは<code class="highlighter-rouge">nil</code>ではない)場合にも、問題なく関数は呼び出されます。</p>

<p>そのため、Goではメソッド内部でレシーバのポインタが<code class="highlighter-rouge">nil</code>であるかを確認することには意味があります。
メソッド内で<code class="highlighter-rouge">nil</code>のチェックが適切に行われている場合、そのメッソドは呼び出し側で<code class="highlighter-rouge">nil</code>チェックをすることなしに呼び出せるようになります。
例えば<a href="https://github.com/golang/protobuf">Goのprotobufの実装</a>はレシーバが<code class="highlighter-rouge">nil</code>の場合でもgetterメッソドは問題なく実行できるように実装されています
(<em>There are getters that return a field’s value if set, and return the field’s default value if unset. The getters work even if the receiver is a nil message.</em>)。
そのためGoのprotobufを利用する場合、例え<code class="highlighter-rouge">GetDoc()</code>の返り値が<code class="highlighter-rouge">nil</code>だったとしても</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">var</span><span class="x"> </span><span class="n">url</span><span class="x"> </span><span class="kt">string</span><span class="x">
</span><span class="n">doc</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">response</span><span class="o">.</span><span class="n">GetDoc</span><span class="p">()</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">doc</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
   </span><span class="n">url</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">doc</span><span class="o">.</span><span class="n">GetURL</span><span class="p">()</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>のように書かずに単純に</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="n">url</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">response</span><span class="o">.</span><span class="n">GetDoc</span><span class="p">()</span><span class="o">.</span><span class="n">GetURL</span><span class="p">()</span></code></pre></figure>

<p>のように書くことが出来ます(GetURLの内部でdocが<code class="highlighter-rouge">nil</code>かどうかがチェックされている)。呼び出し側での<code class="highlighter-rouge">nil</code>チェックの必要性は細かいことですが、<code class="highlighter-rouge">protobuf</code>のようなライブラリの使い勝手には大きく影響します。
メソッド内部でレシーバの<code class="highlighter-rouge">nil</code>チェックが行われていない場合は、レシーバ内で<code class="highlighter-rouge">recv.field</code>を参照した時点、値を代入しようとした時点で<code class="highlighter-rouge">panic</code>が発生します。</p>

<iframe src="https://play.golang.org/p/fQ_0Jzu8M6" frameborder="0" style="width: 100%; height: 400px"><a href="https://play.golang.org/p/fQ_0Jzu8M6">see this code in play.golang.org</a></iframe>

<h1 id="errorerror">errorしか返り値がない関数でerrorを処理し忘れる</h1>
<p>Goではエラーは通常、最後の返り値として呼び出し元に返されます。関数が何か重要な値を返す場合であれば、<code class="highlighter-rouge">_</code>を利用しないかぎりはerrorは無視できないのでerrorを処理し忘れることはあまりないと思います。ただ<a href="https://golang.org/pkg/encoding/json/#Unmarshal">json.Unmarshal</a>のようなerror以外に重要な情報を返さない関数は、エラー以外に返り値がないからといって、うっかり返り値を受け取るのを忘れるとerrorが失われます。</p>

<iframe src="https://play.golang.org/p/E9UM39VxQx" frameborder="0" style="width: 100%; height: 400px"><a href="https://play.golang.org/p/E9UM39VxQx">see this code in play.golang.org</a></iframe>

<p>例えば上のコードは<code class="highlighter-rouge">"not json"</code>はjsonとしてパース出来ないのでエラーが発生しますが、コンパイル時にはエラーが無視されていることは検出されません。これに関しては気をつける以外に解決策はないと思います。</p>

<h1 id="section-2">基本型がメソッドを持たない</h1>
<p><a href="https://golang.org/doc/faq#methods_on_basics">例えばstringがlenをメソッドとして持ちません</a>。これは<a href="https://msdn.microsoft.com/ja-jp/library/system.int32.aspx">C#とかではintですらメソッドを持つ</a>のと真逆を行くように思える。
Goのインターフェースで宣言されているメソッドが実装されていれば、そのインターフェースを実装していることになるという仕様と関係している？</p>

<h1 id="string">stringが単なるバイト列</h1>
<p>Java, C#やPython3などのモダンな言語では文字列(string)はUnicode文字の列ですが、<a href="https://blog.golang.org/strings">Go言語のstringは単なるimmutable(書き換え不可能)なバイト列に過ぎません(In Go, a string is in effect a read-only slice of bytes.)</a>。Goのstringは中身がUTF-8でエンコードされた文字列かも知れませんし、Shift_JISでエンコードされた文字列かもしれません。</p>

<p><a href="https://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit">これは文字列をUnicodeにしたPython3</a>の真逆を行く感じで正直本当に正しいのかはよく分かりません。</p>

<ul>
  <li>Goではファイルなどから<code class="highlighter-rouge">string</code>を読み込む際にエンコードを指定したりはしません。
<a href="https://docs.oracle.com/javase/jp/6/api/java/io/FileReader.html">これは他の言語のようにデフォルトの文字エンコーディングで暗黙的にデコードされている</a>のではなく、
そもそもGoは<code class="highlighter-rouge">string</code>を作る際にデコードを行わないからです。</li>
  <li><code class="highlighter-rouge">len(s)</code>は<code class="highlighter-rouge">s</code>の文字列のバイナリ列としての長さを返します。<strong>文字の数ではない</strong>の注意して下さい。</li>
  <li><a href="https://golang.org/ref/spec#Source_code_representation">Goのソースコードは必ずUTF-8でなくてはならない</a>ので、
ソースコード中に文字列リテラルとして定義された文字列はUTF-8の文字列です。</li>
  <li><a href="https://blog.golang.org/strings#TOC_6.">stringに対するrange-loop(for range)の場合だけ特別に文字列がUTF-8としてデコードされて”一文字”ずつ処理される</a>という少し歪な仕様になっている</li>
  <li><a href="https://play.golang.org/p/KS0JzQ-T8m">A sample on Go Playground</a></li>
</ul>

<h1 id="section-3">継承がない</h1>
<p><a href="https://golang.org/doc/faq#inheritance">Goには継承はありません</a>。
<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">そもそも継承はプログラミング言語にあまり必要ない機能だと思います</a>。
継承が本当に有益なこともありますが、経験上大半のケースでは設計を手抜きするために継承が使われていて、結果長い目で見た際のreadabilityやmaintainabilityが著しく劣化してしまっていることが多いと思います。<a href="https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%B9%E3%82%B3%E3%83%95%E3%81%AE%E7%BD%AE%E6%8F%9B%E5%8E%9F%E5%89%87">リスコフの置換原則</a>のような基本的な原則が守られておらず(そもそも多くの人は名前すら知らない)、単に一部のコードをクラス間で共有するために継承が使われていて可読性が著しく低いコードもよく目にします。
そのため、そもそもプログラミング言語が継承をサポートしないというのは良いことなのかなと思います。
たまに継承が非常に有益なのも分かりますが。</p>

<p><a href="https://golang.org/doc/effective_go.html#embedding">Embedding</a>という機能で複数の型を合成することはできます。多重継承に少し似ていますね。</p>

<h1 id="generics">Genericsがない</h1>
<p><a href="https://golang.org/doc/faq#generics">GoにはGenericsはありません</a>。
<a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html">JavaのGeneric Types</a>とか<a href="https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)">C++のテンプレート</a>で書けるようなことはGoでは書けません。
ただ配列(スライス), mapについては特別に言語でサポートされているのでJavaやC++で総称型を使うケースの大半はカバーされるとは思います。</p>

<h1 id="goroutine-gc">goroutine はGCされない</h1>
<p><a href="https://groups.google.com/d/msg/golang-nuts/uiySuH8_3Y4/nvZoN7l0PxgJ">goroutine はガーベッジコレクションの対象ではありません</a>。
goroutineはGCされないので、<code class="highlighter-rouge">go</code>で起動した関数は必ず終了するように気をつけてプログラムを書きましょう。JavaやPythonの実行中のスレッドがGCに回収されないのと同じですね、自然な仕様だと思います。ただgoroutineは割りと気軽に作成できてしまうので、うっかり新しいgoroutineもGCのルートになることを忘れてしまうかも。</p>

<p>またこの制約のためGoで新しい読み込み専用channelだけを返す関数というのは呼び出し側がchannelからデータ最後まで読み込まないとメモリリークが発生する危険性があります。
例えば標準ライブラリのtime.Tickはとても便利ですが<a href="https://golang.org/pkg/time/#Tick">リークします(「<em>it “leaks”.</em>」)</a>。
そのため、次に述べるようにPythonのyieldに相当することを実現するのにchannelとgoroutineは使わないほうがよいでしょう。</p>

<h1 id="goroutinegenerator-yield-">goroutineはgenerator (yield) の実装には使えない</h1>
<p>Go言語には<a href="https://docs.python.org/2/reference/simple_stmts.html#the-yield-statement">Pythonのyield</a>に相当する機能はありません。ただgoroutineとchannelを組み合わせればyieldに相当することができるのではと思うかもしれません(<a href="https://play.golang.org/p/AeXaSlCuFc">Go Playground</a>)。</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">squareGenerator</span><span class="p">(</span><span class="n">n</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="o">&lt;-</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">ch</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="n">n</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">ch</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">*</span><span class="x"> </span><span class="n">i</span><span class="x">
        </span><span class="p">}</span><span class="x">
        </span><span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span><span class="x">
    </span><span class="p">}()</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">ch</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">squareGenerator</span><span class="p">(</span><span class="m">100</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="m">100</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">break</span><span class="x">
        </span><span class="p">}</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>このコードは意図した通り1, 4, 9…,81, 100を出力します。ただこのやり方には</p>

<ul>
  <li>channel は比較的(Goにしては)遅いのでパフォーマンスが低下する</li>
  <li>goroutine がGCされないので、channelが最後まで読み込まれないとリークする</li>
</ul>

<p>という2つの問題があります。
まずchannelはGoの他の要素に比べるとかなり低速です。channelを通じてchannelの書き込み側のgoroutineと読み込み側のgoroutineの間でコンテキストスイッチを行うのは、<a href="http://ja.stackoverflow.com/questions/2970/go%E3%81%A7%E3%82%B3%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3%E3%82%92%E5%86%8D%E7%8F%BE%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95">関数呼び出しなどに比べると数十倍から百倍ぐらい時間がかかります</a>(Go 1.5時点)。</p>

<p>また上に書いたように、実行中のgoroutineはJavaやPythonのスレッドと同じで<a href="http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html">GCのルート</a>になります。channelへの書き込みでブロックされて停止中のgoroutineもGCの対象ではありません(少なくとも1.5時点では)。そのため、generatorが返したchannelが最後まで呼び出されないとchannelとgoroutineがリークすることになります。</p>

<h1 id="section-4">例外が(推奨され)ない</h1>
<p><a href="https://golang.org/doc/faq#exceptions">Go言語のFAQにあるように、Goには例外がありません</a>。panic, recoverで例外と同じようなことはできますが、Javaの例外のように気軽に使ってはなりません。個人的にはこのFAQにかかれていることには概ね同意します。
例外で返されたエラーを <code class="highlighter-rouge">try {...} catch (Exception e) {...}</code> みたいに処理しないといけないのは無意味に複雑なように思います。
それだけならよいですが、例外が発生するとコードが想定外の順序で実行されて困ったり、何故かこのコードが実行されないなと思ったら、その前に例外で大域脱出していて、しかもその例外が予想外のところでcatchされ握りつぶされていたり、と例外を大規模なプロジェクトの中で正しく扱うのは中々に困難だと思います。
Goの例外は極力使わず、エラーを値として扱うポリシーはよいもの(特に大規模なプロジェクトで、エラーハンドリングが大切なプロジェクトでは)だと思います。</p>

<p>ただ一方で、ちょっとした使い捨ての便利ツールを書く場合や、とりあえずプロトタイプで正常系だけ書きたい時、
あるいは異常が発生したらプログラムを停止してしまって良いような起動時の初期化処理を書く時には、正直Goのエラーハンドリングはかなり面倒くさいです。
こういうタイプのコードでは外部ライブラリの呼び出しやファイル、データベースなどの外部リソースへのアクセスが大きな割合を占めます。そして、そうした処理はほとんどの場合 error が発生しうるのでそれぞれの処理に対してエラーハンドリングを行う必要があります。
場合によってはコードのかなりの割合の行が</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>の繰り返しで占められてしまうこともあるでしょう。これに対しては根本的な解決策はないように思います。エラーが発生した場合はエラーメッセージを出力して処理を中断してしまって問題ない</p>

<ul>
  <li>使い捨てあるいは内部ツールで開発者・利用者の数が数人でエラーハンドリングがあまり重要ではない時</li>
  <li>正常系だけとりあえずプロトタイプしたい時</li>
</ul>

<p>には例外の方が便利であり、正直Go言語ではあまり効率的にコードが書けないような気がします。個人的にはそういう用途にはPythonなどを使うのが正しい解決策のように思えます。何でもGoで書く必要はないのですから。</p>

<h1 id="if-err--nil-return-err">繰り返す if err != nil {return err}</h1>
<p>Goでは例外が推奨されずエラー処理を常にきちんと書かなくてはならないので、Goでプログラムを書いていると</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="c">// ...</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="c">// ...</span><span class="x">
</span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="c">// ....</span></code></pre></figure>

<p>のように <code class="highlighter-rouge">if err != nil</code> によるエラーハンドリングを繰り返し繰り返し書かなくてはならないことがあります。
<a href="https://blog.golang.org/errors-are-values">Go Blog</a>には<code class="highlighter-rouge">if err != nil { return err }</code>のパターンはあまり出現しない(once per page or two)と書かれていますが、
プログラムのタイプによっては(例えばいろいろな外部リソースや外部ライブラリをつなぐようなコード)かなりの頻度で <code class="highlighter-rouge">if err != nil</code> を書かざるを得ないことがあるような気がします。
<code class="highlighter-rouge">if err != nil</code> を入力するショートカット定義したほうがいいんじゃないのという気分になることがたまにあります。</p>

<h2 id="section-5">解決策</h2>
<p><code class="highlighter-rouge">// ...</code> の部分のコードが同じ処理の繰り返しであれば<a href="https://blog.golang.org/errors-are-values">前述のGo Blog</a>に書かれているように <code class="highlighter-rouge">if err != nil</code> の繰り返しを避けることが出来ます。<code class="highlighter-rouge">if err != nil</code>が繰り返しているなと思ったら、そもそも<code class="highlighter-rouge">if err != nil</code>以外の部分も繰り返しになっていないか、繰り返している処理をひとまとめにできないかを考えてみるべきでしょう。</p>

<p>一方で、このテクニックが利用できるのは<code class="highlighter-rouge">...</code>の部分の処理が同じ型の処理の組み合わせでコードをまとめられる場合に限られます。そもそもコードが一定以上繰り返していたらまとめたほうが良いというのは、特に<code class="highlighter-rouge">if err != nil</code>とは関係なく行なうべきことでしょう。Goだと関数内の内部で更に関数を定義できるので、関数の一部の処理を気軽にまとめることができます、すばらしいことです。ただ<code class="highlighter-rouge">// ...</code>の処理に共通点があまりなく綺麗にまとめることができない場合は、<code class="highlighter-rouge">if err != nil</code> の繰り返しは我慢する以外によい解決策はないようです。</p>

<h1 id="return-nil-err--error">return nil, err → このerrorどこで発生したの？</h1>
<p>Goではエラーハンドリングをきちんと書かなくてはなりません。とはいえ、きちんと書くと言ってもエラーが発生したら単に処理を中断してエラーを呼び出し元に返すことでエラー処理を呼び出し元に丸投げしてしまうことが多いでしょう。</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>そして最後に一番外側の処理でエラーを出力します</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="c">// ...</span><span class="x">
  </span><span class="n">result</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">doSomething</span><span class="p">()</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="x">
  </span><span class="p">}</span><span class="x">
  </span><span class="c">// ...</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>プログラムを走らせたらエラーが発生してエラーが出力されました。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Invalid Argument
</code></pre>
</div>

<p>あれ…このエラーどこで発生したの…</p>

<p>Goのエラーはただの値なのでJavaやPythonの例外などと違ってスタックトレースを含みません。
Goのエラーには、そのエラーがどこで発生したかというコンテキストが自動的には含まれないのです。
そのため、エラーハンドリングを呼び出し元に任せるからといってerrorを呼び出し元に何も考えずに返していると最終的にそのエラーがどこで発生したのかが分からなくなってしまいます。
なので、errorを呼び出しに返すときは手動でエラーのコンテキストを残してあげましょう。</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="k">return</span><span class="x"> </span><span class="no">nil</span><span class="p">,</span><span class="x"> </span><span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"Some context: %v"</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="p">)</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>これでエラーがどこで発生したのかが分かるようになります。ただこういうことしてると実は例外で良かったんじゃないかという気分にもなりますが。</p>

<h1 id="defer">関数より狭いスコープで defer</h1>
<p>C#のusing, Pythonのwithのように他の人気のある言語ではあるスコープから処理が抜ける際に、リソースの解放処理を確実に実行するための機能がサポートされています。<a href="http://www.ne.jp/asahi/hishidama/home/tech/java/statement.html#try_with_resources_statement">Javaでも1.7からtry-with-resources</a>がサポートされています。
Goではそういった解放処理は<code class="highlighter-rouge">defer</code>を使って行います。
ただC#のusing, Pythonのwith, Javaのtry-with-resourcesと違ってGoの<code class="highlighter-rouge">defer</code>は一定のスコープを抜けた時ではなく、関数が終了する際に確実に指定した処理を実行する仕組みです。
そのため、次のようなコードを書いても<code class="highlighter-rouge">r.Close()</code>が実行されるのは <code class="highlighter-rouge">if condition</code>のif文のブロックが終了した時ではなく<code class="highlighter-rouge">myFunc</code>全体が終了した時になってしまいます。</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">func</span><span class="x"> </span><span class="n">myFunc</span><span class="p">()</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="c">// ...</span><span class="x">
  </span><span class="n">r</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
  </span><span class="p">}</span><span class="x">
  </span><span class="k">defer</span><span class="x"> </span><span class="n">r</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span><span class="x">
  </span><span class="n">data</span><span class="p">,</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">readDataFromReader</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="x">  </span><span class="c">// 実際にはもう少し複雑な処理</span><span class="x">
  </span><span class="k">if</span><span class="x"> </span><span class="n">err</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="no">nil</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">err</span><span class="x">
  </span><span class="p">}</span><span class="x">
  </span><span class="c">// この時点でr.Close()を本当は呼びたいが、myFuncの終了まで呼び出されない。</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<h1 id="structcjava">structとC++/Javaのクラスとの違い</h1>
<p>これもはまりどころというよりは、Goでコードを書く上で理解しておきたいポイントの整理ですが。
GoのstructとC++/Javaのクラスの、コードを書く上での理解しておくべき大きな違いは、struct (class) の初期化の方法の違い(コンストラクタがない)から来ます。</p>

<h2 id="section-6">コンストラクタがない</h2>
<p>Goにはコンストラクタがありません。GoではC++、Javaのコンストラクタに相当する関数を単なる関数として定義します。ただこれは定義方法がC++, Javaと違うというだけで、実際にコードを書くときには大した違いはないように思います。</p>

<p>Goではstructは通常</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">var</span><span class="x"> </span><span class="n">mydata</span><span class="x"> </span><span class="n">MyData</span><span class="x">
</span><span class="n">mydata</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&amp;</span><span class="n">MyData</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">X</span><span class="o">:</span><span class="x"> </span><span class="m">10</span><span class="p">,</span><span class="x">
    </span><span class="n">Y</span><span class="o">:</span><span class="x"> </span><span class="m">20</span><span class="p">,</span><span class="x">
</span><span class="p">}</span></code></pre></figure>

<p>のように<a href="https://golang.org/ref/spec#Composite_literals">StructType{name: value,…}</a>で初期化します。{name: value}が省略された場合はゼロ初期化されます。Goにはコンストラクタは存在しません。Goであるstructの初期化関数を用意したい場合には、パッケージに生成用の関数を用意します。通常、関数の名前はNew+struct名(+付加情報)のようになります。例えば、bytes.Bufferには []byteからbytes.Bufferを生成する bytes.NewBuffer と string からbytes.Bufferを生成するbytes.NewBufferStringが用意されています。</p>

<h2 id="section-7">ゼロ初期化が避けられない</h2>
<p>Goでは、structのメンバー変数をパッケージ外に非公開にすることができます。非公開になっているメンバーは他のパッケージから直接編集することはできません。ただし、structがパッケージ外に公開されている場合、例え全ての変数が非公開だったとしても</p>

<figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">var</span><span class="x"> </span><span class="n">mydata</span><span class="x"> </span><span class="n">MyData</span></code></pre></figure>

<p>のように書かれてしまうと、MyDataの中身は全てゼロ値で初期化されてしまいます。C++/やJavaではコンストラクタに書かれているようにしか非公開のメンバーは変更できないので、メンバーがどのように初期化されるかは明示することができます。しかしGoではそのようなことはできません。structが外部に公開されるのならばstructは全てがゼロ初期化された場合にも正しく動くように常に設計しなくてはならないのです。</p>

<h2 id="section-8">コピーされるのが避けられない</h2>
<p>GoではC++のコピーコンストラクタのような仕組みはないので、structのコピーを防止することは不可能です。公開されているstructは他のパッケージのコードで自由にコピーができてしまいます。実はGoははじめのころは非公開のメンバーがあるstructはパッケージ外部ではコピーすることはできませんでした。しかし、<a href="https://go.googlesource.com/go/+/d03611f628c65321b572ab0d4ce85cc61b759fc6">2011年に仕様が変更</a>されて非公開のメンバーが存在してもコピー可能なようになりました。</p>

<p>そのためパッケージ外部に公開されているstructはコピーされても不都合が(あまり)起こらないようにすべきです。コピーされると非常に不都合なstructはinterfaceだけを公開して実際の実装であるstructを隠すか、あるいはコピーされたくないフィールドを別のstructに分離して公開するstructではそのstructへのポインタを保持するようにします。
例えば<a href="https://golang.org/pkg/os/#File">標準ライブラリのos.File</a>は、ソースコードを見るとファイルディスクリプタなどを管理する private な <code class="highlighter-rouge">os.file struct</code> へのポインタとなっています。これはファイルの実体に対応する構造体<code class="highlighter-rouge">os.file</code>がコピーされて同じファイルが2回閉じられたりするようなことが起こらないように配慮された結果です。</p>

<p>ちなみにos.Fileは<code class="highlighter-rouge">*os.file</code>を1つ持つだけの<code class="highlighter-rouge">struct</code>ですが、これを<code class="highlighter-rouge">type File *file</code>としては意味がありません。なぜなら<code class="highlighter-rouge">type File *file</code>としてしまうと、<code class="highlighter-rouge">os.File</code>はポインタなので例え<code class="highlighter-rouge">os.file</code>が非公開だとしても<code class="highlighter-rouge">*</code>演算でポインタの実体が参照できてしまい、<code class="highlighter-rouge">*file0 = *file1</code>のように書くことで<code class="highlighter-rouge">os.file</code>のコピーがパッケージ外部でもできてしまうからです。</p>

<h1 id="section-9">キャストという概念がない</h1>
<p>Go (golang) にはキャストがありません。そもそもC++やJavaのキャストは
- プリミティブ型のデータ変換(int→float)
- 親クラス、インターフェイスへの参照をサブクラス参照へと型を変更(Object→String)
という2つの全く異なる処理が「キャスト」という概念に統合されてしまっています。
そのため<a href="http://www.yunabe.jp/docs/cpp_casts.html">C++では旧来のキャストに加えて4つのキャスト演算がサポートされたりしています</a>。
Goではこの２つの処理は全く異なるシンタックスで扱われます。そもそも全く異なる処理なのだから、Goのやり方のほうが正しいです。</p>

<ul>
  <li>プリミティブ型のデータ変換
    <ul>
      <li><code class="highlighter-rouge">int</code>→<code class="highlighter-rouge">float</code>などのプリミティブ型間のデータ変換には <code class="highlighter-rouge">newtype(val)</code> を使います。</li>
      <li><code class="highlighter-rouge">int64(f)</code>, <code class="highlighter-rouge">float64(i)</code> など</li>
      <li><code class="highlighter-rouge">[]byte</code>と<code class="highlighter-rouge">string</code>の変換も非常によく使います。<code class="highlighter-rouge">[]byte(str)</code>, <code class="highlighter-rouge">string(binary)</code></li>
    </ul>
  </li>
  <li>interfaceから実体を取り出す
    <ul>
      <li><code class="highlighter-rouge">obj.(subType)</code>という少し風変わりなシンタックスで処理します。</li>
      <li>Javaで親クラスからサブクラスに、インターフェイスからサブインターフェイスに変換するのに相当する処理です。
interfaceからその実体のstructやstructのポインタ、あるいはより詳細なinterfaceに変換します。</li>
      <li>このシンタックスは3通りの使い方があります。</li>
      <li><code class="highlighter-rouge">s := obj.(*myStruct)</code>
        <ul>
          <li>interface <code class="highlighter-rouge">obj</code>を<code class="highlighter-rouge">*myStruct</code>として扱えるかをチェックし、可能な場合は<code class="highlighter-rouge">*myStruct</code>を取り出します。
そうでない場合は<strong>panic</strong>します。</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">s, ok := obj.(*myStruct)</code>
        <ul>
          <li>上記とほぼ同じですが、panicする代わりにチェック結果を<code class="highlighter-rouge">bool</code>値の<code class="highlighter-rouge">ok</code>に格納します。<code class="highlighter-rouge">ok</code>であって<code class="highlighter-rouge">error</code>でないので注意。</li>
          <li>失敗した場合は、<code class="highlighter-rouge">s</code>には<code class="highlighter-rouge">nil</code>などが入ります。</li>
        </ul>
      </li>
      <li><a href="https://golang.org/doc/effective_go.html#type_switch">type switch</a>
        <ul>
          <li><code class="highlighter-rouge">s, ok := obj.(subType)</code>を複数の型に対して行って条件分岐するのを簡潔に記述するための特殊な構文が用意されています。</li>
        </ul>
      </li>
      <li><a href="https://play.golang.org/p/7TQNQZxEbZ">An example on Go Playground</a></li>
    </ul>
  </li>
</ul>

<h1 id="section-10">型が後置</h1>
<p>これは慣れです。C, Java系をメインで使っている多くのプログラマには最初は違和感があります。でも使っていれば割とどちらでもいいなという気分になります。
とはいえ後置の言語と前置の言語両方書いてるとたまに混乱します。</p>

<h1 id="section-11">1.0 が浮動小数点型にならない(時がある)</h1>
<p>https://play.golang.org/p/JjB2WDohT3</p>

<h1 id="section-12">名前が…</h1>
<p>何でこんな検索しにくい名前なのだろうな…結果golangで検索する羽目になるなら最初からgolangという名前だったらまだ良かったのにと思います。</p>

        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <div class="fb-comments" data-href="http://www.yunabe.jp/docs/golang_pitfall.html"  data-numposts="5"></div>
        <div style="text-align:center">
          <a href="/docs">Home</a>
        </div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8&appId=234187763701556";
  fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));</script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<script src="https://apis.google.com/js/platform.js" async defer>
  {lang: 'ja'}
</script>
<script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>

    
  </body>

</html>
