<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Python の メタプログラミング (__metaclass__, メタクラス) を理解する</title>
  <meta name="description" content="">
  <meta property="fb:admins" content="yunabe">
  <meta property="fb:app_id" content="234187763701556">
  <meta property="og:url" href="http://www.yunabe.jp/docs/python_metaclass.html">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://www.yunabe.jp/docs/python_metaclass.html">
  <link rel="alternate" type="application/rss+xml" title="" href="http://www.yunabe.jp/feed.xml">
  <script>
    if(location.host=='www.yunabe.jp'){
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-19477574-2', 'yunabe.jp');
    ga('require', 'displayfeatures');
    ga('send', 'pageview');
    }
  </script>
</head>


  <body>
    <div class="page-content">
      <div class="wrapper">
        <header class="post-header">
          <h1 class="post-title" itemprop="name headline">Python の メタプログラミング (__metaclass__, メタクラス) を理解する</h1>
          <p class="post-meta"><time datetime="2015-01-14T00:00:00+09:00" itemprop="datePublished">更新 Jan 14, 2015</time></p>
        </header>
        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <p>Pythonのメタプログラミング (__metaclass__) は組み込み関数 <code class="highlighter-rouge">type</code>
の普段利用しない隠れた機能や、 普通は利用しない特殊メソッド <code class="highlighter-rouge">__new__</code>
などを理解する必要があり 理解するのが結構難しい。
あまり関連情報がまとまってるドキュメントがなくて理解するのに苦労したので情報をまとめておきました。</p>

<ul id="markdown-toc">
  <li><a href="#type-" id="markdown-toc-type-">type とクラス定義のあまり知られていない関係</a></li>
  <li><a href="#new" id="markdown-toc-new">特殊メソッド __new__</a></li>
  <li><a href="#type" id="markdown-toc-type">typeの継承</a></li>
  <li><a href="#section" id="markdown-toc-section">実装の解説</a></li>
</ul>

<p>#事前知識</p>

<p><a href="https://docs.python.org/2/reference/datamodel.html#customizing-class-creation">Customizing class creation</a>
(<a href="http://docs.python.jp/2/reference/datamodel.html#metaclasses">日本語:クラス生成をカスタマイズする</a>)
を読むと、型を取得するのに普通利用するbuiltin関数 <code class="highlighter-rouge">type</code>
を継承していたり、 普通利用することのない <code class="highlighter-rouge">__new__</code>
が定義されていたりして、 <code class="highlighter-rouge">type</code> の隠された機能と <code class="highlighter-rouge">__new__</code>
について理解していないと
何が書かれているかさっぱり分からないと思います。 まずは <code class="highlighter-rouge">__metaclass__</code>
を理解する上で重要なこの2つについて整理しておきましょう。</p>

<h2 id="type-">type とクラス定義のあまり知られていない関係</h2>

<p>ご存知のように Python には <code class="highlighter-rouge">type</code> という builtin
関数が定義されています。 type は <code class="highlighter-rouge">type(obj)</code> のように1つの引数を与えて
obj の型を取得するのに利用したことがあるはずです。
普通はこちらの機能しか使いません。</p>

<p>しかし実は type にはもう一つの隠れた機能があります。
<a href="http://docs.python.jp/2/library/functions.html#type">第1引数に文字列でクラス名、第2引数に親クラスの列、第3引数にクラスのメソッドや属性を定義した
dict を渡して type
を呼び出すとクラスを動的に定義することが可能です。</a></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">ClassName</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">P1</span><span class="p">):</span>
  <span class="n">attrivute1</span> <span class="o">=</span> <span class="n">value1</span>

  <span class="k">def</span> <span class="nf">function1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="o">...</span></code></pre></figure>

<p>のように普段クラスを定義していると思いますが、これは <code class="highlighter-rouge">type</code> を使うと:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">function1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
   <span class="o">...</span>

<span class="n">ClassName</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">'ClassName'</span><span class="p">,</span>
                 <span class="p">[</span><span class="n">P0</span><span class="p">,</span><span class="n">P1</span><span class="p">,],</span>
                 <span class="p">{</span><span class="s">'attribute1'</span><span class="p">:</span> <span class="n">value1</span><span class="p">,</span>
                  <span class="s">'function1'</span><span class="p">:</span> <span class="n">function1</span><span class="p">,})</span></code></pre></figure>

<p>のように定義することも可能です。この2つの定義は全く同じ実行結果が得られます。
ここで2つ目の type を使った定義をよく見てみると、 実は ClassName は type
クラスにクラス名、親クラス、クラス定義を渡してインスタンス生成
したものだということが分かります。クラスは <strong>type のインスタンス</strong>
なのです。 その証拠に <code class="highlighter-rouge">type(cls)</code> は <code class="highlighter-rouge">type</code> を返しますし、
<code class="highlighter-rouge">isinstance(cls, type)</code> は True を返します。</p>

<h2 id="new">特殊メソッド __new__</h2>

<p>Python
でクラスを定義する際、インスタンスを初期化するメソッドとして普通は
<code class="highlighter-rouge">__init__</code> を定義します。 厳密には Python
には「コンストラクタ」という用語はありませんが、 C++/Java
におけるコンストラクタに相当する処理は普通 <code class="highlighter-rouge">__init__</code> に書かれます。
しかし実は Python にはインスタンスの生成方法を定義するもう一つの
<a href="https://docs.python.org/2/reference/datamodel.html#object.__new__">特殊メソッド
__new__</a>
が存在します (<a href="http://docs.python.jp/2/reference/datamodel.html#object.__new__">__new__
の日本語のドキュメント</a>)。</p>

<p>Python でクラスを定義して、それを呼び出してインスタンスの生成を行うと
<code class="highlighter-rouge">__init__</code> が
暗黙的に呼び出されインスタンスの初期化が行われると理解していると思いますが、
実はその前に <code class="highlighter-rouge">__new__</code> による処理が存在しています。
クラスのインスタンス生成を行った際に暗黙的に行われている処理はより正確に書くと</p>

<ul>
  <li><code class="highlighter-rouge">class ClassName</code> が <code class="highlighter-rouge">ClassName()</code>
によってインスタンス生成された場合</li>
  <li>まず <code class="highlighter-rouge">ClassName.__new__</code> が第1引数に ClassName, 残りの引数に
ClassName に与えた残りの引数が与えられて呼び出される。</li>
  <li>普通は <code class="highlighter-rouge">__new__</code>
は定義されていないので親クラスをたどっていって最終的に
<code class="highlighter-rouge">object.__new__</code> が呼び出される。<code class="highlighter-rouge">object.__new__</code>
は第1引数で与えられた
クラスのインスタンスを生成して返す。<code class="highlighter-rouge">object.__new__</code>
が返すインスタンスは <code class="highlighter-rouge">__init__</code>
が実行される前の未初期化のインスタンスである点に注意。</li>
  <li><code class="highlighter-rouge">__new__</code> が ClassName のインスタンスを返した場合に限り
<code class="highlighter-rouge">ClassName.__init__</code> が呼び出される。</li>
</ul>

<p>というようになっています。 例えばものすごく極端な例ですが:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'__init__'</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span>
<span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></code></pre></figure>

<p>のようなコードを書くと、<code class="highlighter-rouge">c</code> には <code class="highlighter-rouge">'43'</code> が代入されます。 そして
<code class="highlighter-rouge">__init__</code> は呼び出されません。</p>

<p><code class="highlighter-rouge">__new__</code> の役割はかなり理解しづらいと思うので
よくドキュメントを読んでサンプルを書いて動かしていろいろ試してみたほうがよいかと思います。
個人的には ClassNameを呼び出すと <code class="highlighter-rouge">__init__</code> が暗黙的に呼び出されるという
先入観が強すぎるせいか、 <code class="highlighter-rouge">__new__</code>
で何が制御できるのか理解するのがなかなか大変でした。</p>

<p>#__metaclass__
class を定義すると自動的に <code class="highlighter-rouge">type('ClassName', ...)</code>
が呼び出されてクラスが生成されるということを type の節で述べました。
実は Python ではこの class
を定義される際に暗黙的に呼び出される関数を別の関数で置き換えることができます。
これが
<a href="https://docs.python.org/2.7/reference/datamodel.html#__metaclass__">__metaclass__</a>
です (<a href="http://docs.python.jp/2/reference/datamodel.html#__metaclass__">__metaclass__
の日本語のドキュメント</a>)。</p>

<p>classの定義に <code class="highlighter-rouge">__metaclass__</code> が存在するとクラスを生成する際に
<code class="highlighter-rouge">__metaclass__</code> に格納された関数が <code class="highlighter-rouge">type</code> の代わりに呼び出されます。
metaclass という名前がついていますが、<code class="highlighter-rouge">__metaclass__</code> は class
である必要はありません。 <code class="highlighter-rouge">type</code> と同様の引数を受け取れる callable
なオブジェクトならば何でも <code class="highlighter-rouge">__metaclass__</code> として利用できます。 例えば</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">tolower_classname</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ClassName</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">tolower_classname</span>

  <span class="k">print</span> <span class="n">ClassName</span><span class="o">.</span><span class="n">__name__</span>  <span class="c"># classname</span></code></pre></figure>

<p>のようなコードを書くと、ClassName の名前が ‘classname’ になります
(classname というクラスが ClassName という変数に格納されている状態)。</p>

<h2 id="type">typeの継承</h2>

<p>ただそれだと metaclass
という名称とマッチしないので、実際にはtypeを継承したクラスを作成してそれを
<code class="highlighter-rouge">__metaclass__</code> に指定するのが一番自然なのではないかと思います。
その場合、 <code class="highlighter-rouge">__metaclass__</code>
に指定されたクラスのインスタンスとしてクラスが作成されるようになるので、
クラス作成をカスタマイズするには <code class="highlighter-rouge">__metaclass__</code> に指定したクラスの
<code class="highlighter-rouge">__new__</code> もしくは <code class="highlighter-rouge">__init__</code> をカスタマイズすることになります。</p>

<p><code class="highlighter-rouge">type</code> は <code class="highlighter-rouge">__init__</code> ではなく <code class="highlighter-rouge">__new__</code>
メソッドの方でクラス生成の主な作業を行っています (<a href="http://svn.python.org/projects/python/trunk/Objects/typeobject.c">typeobject.c
ソースコード</a>)。
そのため、 <code class="highlighter-rouge">type</code> の挙動をカスタマイズするには、普段オーバーライドする
<code class="highlighter-rouge">__init__</code> ではなくて、 <code class="highlighter-rouge">__new__</code>
メソッドをオーバーライドする必要があります。 そして <code class="highlighter-rouge">type.__new__</code>
を呼び出す前に引数の <code class="highlighter-rouge">name</code>, <code class="highlighter-rouge">bases</code>, <code class="highlighter-rouge">dict</code>
を編集してクラス生成をカスタマイズすることになります。</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">mymeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="c"># TODO: customize name, bases, dict.</span>
    <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span></code></pre></figure>

<p>#メタクラスの例</p>

<p><code class="highlighter-rouge">__metaclass__</code>
でどんなことができるのか理解するには例をみてみるのが一番だと思うので、
メタクラスのサンプルとして、<code class="highlighter-rouge">__metaclass__</code> に指定すると getter/setter
っぽい名前のメソッド (e.g. <code class="highlighter-rouge">get_name</code>, <code class="highlighter-rouge">getName</code>, <code class="highlighter-rouge">SetName</code>) を自動的に
<a href="http://docs.python.jp/2/library/functions.html#property">プロパティ</a>
に変換してくれるメタクラス <a href="https://github.com/yunabe/practice/tree/master/python/metaclass/">auto_property
(ソースコード)</a>
を作成しました。 例えば <code class="highlighter-rouge">get_x</code>
というメソッドを持つクラスに指定すると、アクセスすると <code class="highlighter-rouge">get_x</code>
が呼び出されるプロパティ <code class="highlighter-rouge">x</code> が自動的に生成されます。 （逆に <code class="highlighter-rouge">get_x</code>
はメソッドから消えます）</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">auto_property</span>

  <span class="k">def</span> <span class="nf">get_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">123</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">123</span></code></pre></figure>

<h2 id="section">実装の解説</h2>

<p>まずは <code class="highlighter-rouge">type</code> を継承したクラス auto_property を定義します。 そして
<code class="highlighter-rouge">__new__</code> の中で引数として受け取ったクラス定義の辞書 <code class="highlighter-rouge">dict</code>
をカスタマイズしてから、 <code class="highlighter-rouge">type.__new__</code> を呼び出します。</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">auto_property</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="c"># TODO: dict から setter/getter っぽい名前のメソッドを取り除いて、</span>
    <span class="c">#       代わりに対応する property を持つ new_dict を作成する</span>
    <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">new_dict</span><span class="p">)</span></code></pre></figure>

<p>後は、 TODO の部分で <code class="highlighter-rouge">dict</code> に対して for文を回して正規表現を使って
getter/setter と property 名を取り出して、 最後に <code class="highlighter-rouge">new_dict</code> に対して
<code class="highlighter-rouge">property(getter, setter)</code> を代入するだけです。</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">auto_property</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">setters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">getters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
      <span class="n">value</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="c"># TODO: setter/getter を正規表現で検出</span>

    <span class="k">for</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
      <span class="n">getter</span> <span class="o">=</span> <span class="n">getters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">property_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
      <span class="n">setter</span> <span class="o">=</span> <span class="n">setters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">property_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
      <span class="n">new_dict</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">setter</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">new_dict</span><span class="p">)</span></code></pre></figure>

<p><a href="https://github.com/yunabe/practice/tree/master/python/metaclass/">githubにソースコードをコミットしてある</a>
ので、実装の細かい部分はそちらを確認して下さい。</p>


        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <div class="fb-comments" data-href="http://www.yunabe.jp/docs/python_metaclass.html"  data-numposts="5"></div>
        <div style="text-align:center">
          <a href="/docs">Home</a>
        </div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8&appId=234187763701556";
  fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));</script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<script src="https://apis.google.com/js/platform.js" async defer>
  {lang: 'ja'}
</script>
<script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>

    
  </body>

</html>
