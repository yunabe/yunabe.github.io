<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Python の メタプログラミング (__metaclass__, メタクラス) を理解する</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://www.yunabe.jp/docs/python_metaclass.html">
  <link rel="alternate" type="application/rss+xml" title="" href="http://www.yunabe.jp/feed.xml">
  <script>
    if(location.host=='www.yunabe.jp'){
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-19477574-2', 'yunabe.jp');
    ga('require', 'displayfeatures');
    ga('send', 'pageview');
    }
  </script>
</head>


  <body>
    <div class="page-content">
      <div class="wrapper">
        <header class="post-header">
          <h1 class="post-title" itemprop="name headline">Python の メタプログラミング (__metaclass__, メタクラス) を理解する</h1>
          <p class="post-meta"><time datetime="2015-01-14T00:00:00+09:00" itemprop="datePublished">更新 Jan 14, 2015</time></p>
        </header>
        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <p>Pythonのメタプログラミング (__metaclass__) は組み込み関数 <code>type</code>
の普段利用しない隠れた機能や、 普通は利用しない特殊メソッド <code>__new__</code>
などを理解する必要があり 理解するのが結構難しい。
あまり関連情報がまとまってるドキュメントがなくて理解するのに苦労したので情報をまとめておきました。</p>

<ul id="markdown-toc">
  <li><a href="#section">事前知識</a>    <ul>
      <li><a href="#type-">type とクラス定義のあまり知られていない関係</a></li>
      <li><a href="#new">特殊メソッド __new__</a></li>
    </ul>
  </li>
  <li><a href="#metaclass">__metaclass__</a>    <ul>
      <li><a href="#type">typeの継承</a></li>
    </ul>
  </li>
  <li><a href="#section-1">メタクラスの例</a>    <ul>
      <li><a href="#section-2">実装の解説</a></li>
    </ul>
  </li>
</ul>

<h1 id="section">事前知識</h1>

<p><a href="https://docs.python.org/2/reference/datamodel.html#customizing-class-creation">Customizing class creation</a>
(<a href="http://docs.python.jp/2/reference/datamodel.html#metaclasses">日本語:クラス生成をカスタマイズする</a>)
を読むと、型を取得するのに普通利用するbuiltin関数 <code>type</code>
を継承していたり、 普通利用することのない <code>__new__</code>
が定義されていたりして、 <code>type</code> の隠された機能と <code>__new__</code>
について理解していないと
何が書かれているかさっぱり分からないと思います。 まずは <code>__metaclass__</code>
を理解する上で重要なこの2つについて整理しておきましょう。</p>

<h2 id="type-">type とクラス定義のあまり知られていない関係</h2>

<p>ご存知のように Python には <code>type</code> という builtin
関数が定義されています。 type は <code>type(obj)</code> のように1つの引数を与えて
obj の型を取得するのに利用したことがあるはずです。
普通はこちらの機能しか使いません。</p>

<p>しかし実は type にはもう一つの隠れた機能があります。
<a href="http://docs.python.jp/2/library/functions.html#type">第1引数に文字列でクラス名、第2引数に親クラスの列、第3引数にクラスのメソッドや属性を定義した
dict を渡して type
を呼び出すとクラスを動的に定義することが可能です。</a></p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">ClassName</span><span class="p">(</span><span class="n">P0</span><span class="p">,</span> <span class="n">P1</span><span class="p">):</span>
  <span class="n">attrivute1</span> <span class="o">=</span> <span class="n">value1</span>

  <span class="k">def</span> <span class="nf">function1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="o">...</span></code></pre></div>

<p>のように普段クラスを定義していると思いますが、これは <code>type</code> を使うと:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">function1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
   <span class="o">...</span>

<span class="n">ClassName</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s">'ClassName'</span><span class="p">,</span>
                 <span class="p">[</span><span class="n">P0</span><span class="p">,</span><span class="n">P1</span><span class="p">,],</span>
                 <span class="p">{</span><span class="s">'attribute1'</span><span class="p">:</span> <span class="n">value1</span><span class="p">,</span>
                  <span class="s">'function1'</span><span class="p">:</span> <span class="n">function1</span><span class="p">,})</span></code></pre></div>

<p>のように定義することも可能です。この2つの定義は全く同じ実行結果が得られます。
ここで2つ目の type を使った定義をよく見てみると、 実は ClassName は type
クラスにクラス名、親クラス、クラス定義を渡してインスタンス生成
したものだということが分かります。クラスは <strong>type のインスタンス</strong>
なのです。 その証拠に <code>type(cls)</code> は <code>type</code> を返しますし、
<code>isinstance(cls, type)</code> は True を返します。</p>

<h2 id="new">特殊メソッド __new__</h2>

<p>Python
でクラスを定義する際、インスタンスを初期化するメソッドとして普通は
<code>__init__</code> を定義します。 厳密には Python
には「コンストラクタ」という用語はありませんが、 C++/Java
におけるコンストラクタに相当する処理は普通 <code>__init__</code> に書かれます。
しかし実は Python にはインスタンスの生成方法を定義するもう一つの
<a href="https://docs.python.org/2/reference/datamodel.html#object.__new__">特殊メソッド
__new__</a>
が存在します (<a href="http://docs.python.jp/2/reference/datamodel.html#object.__new__">__new__
の日本語のドキュメント</a>)。</p>

<p>Python でクラスを定義して、それを呼び出してインスタンスの生成を行うと
<code>__init__</code> が
暗黙的に呼び出されインスタンスの初期化が行われると理解していると思いますが、
実はその前に <code>__new__</code> による処理が存在しています。
クラスのインスタンス生成を行った際に暗黙的に行われている処理はより正確に書くと</p>

<ul>
  <li><code>class ClassName</code> が <code>ClassName()</code>
によってインスタンス生成された場合</li>
  <li>まず <code>ClassName.__new__</code> が第1引数に ClassName, 残りの引数に
ClassName に与えた残りの引数が与えられて呼び出される。</li>
  <li>普通は <code>__new__</code>
は定義されていないので親クラスをたどっていって最終的に
<code>object.__new__</code> が呼び出される。<code>object.__new__</code>
は第1引数で与えられた
クラスのインスタンスを生成して返す。<code>object.__new__</code>
が返すインスタンスは <code>__init__</code>
が実行される前の未初期化のインスタンスである点に注意。</li>
  <li><code>__new__</code> が ClassName のインスタンスを返した場合に限り
<code>ClassName.__init__</code> が呼び出される。</li>
</ul>

<p>というようになっています。 例えばものすごく極端な例ですが:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'__init__'</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">43</span><span class="p">)</span>
<span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></code></pre></div>

<p>のようなコードを書くと、<code>c</code> には <code>'43'</code> が代入されます。 そして
<code>__init__</code> は呼び出されません。</p>

<p><code>__new__</code> の役割はかなり理解しづらいと思うので
よくドキュメントを読んでサンプルを書いて動かしていろいろ試してみたほうがよいかと思います。
個人的には ClassNameを呼び出すと <code>__init__</code> が暗黙的に呼び出されるという
先入観が強すぎるせいか、 <code>__new__</code>
で何が制御できるのか理解するのがなかなか大変でした。</p>

<h1 id="metaclass">__metaclass__</h1>
<p>class を定義すると自動的に <code>type('ClassName', ...)</code>
が呼び出されてクラスが生成されるということを type の節で述べました。
実は Python ではこの class
を定義される際に暗黙的に呼び出される関数を別の関数で置き換えることができます。
これが
<a href="https://docs.python.org/2.7/reference/datamodel.html#__metaclass__">__metaclass__</a>
です (<a href="http://docs.python.jp/2/reference/datamodel.html#__metaclass__">__metaclass__
の日本語のドキュメント</a>)。</p>

<p>classの定義に <code>__metaclass__</code> が存在するとクラスを生成する際に
<code>__metaclass__</code> に格納された関数が <code>type</code> の代わりに呼び出されます。
metaclass という名前がついていますが、<code>__metaclass__</code> は class
である必要はありません。 <code>type</code> と同様の引数を受け取れる callable
なオブジェクトならば何でも <code>__metaclass__</code> として利用できます。 例えば</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">tolower_classname</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ClassName</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">tolower_classname</span>

  <span class="k">print</span> <span class="n">ClassName</span><span class="o">.</span><span class="n">__name__</span>  <span class="c"># classname</span></code></pre></div>

<p>のようなコードを書くと、ClassName の名前が ‘classname’ になります
(classname というクラスが ClassName という変数に格納されている状態)。</p>

<h2 id="type">typeの継承</h2>

<p>ただそれだと metaclass
という名称とマッチしないので、実際にはtypeを継承したクラスを作成してそれを
<code>__metaclass__</code> に指定するのが一番自然なのではないかと思います。
その場合、 <code>__metaclass__</code>
に指定されたクラスのインスタンスとしてクラスが作成されるようになるので、
クラス作成をカスタマイズするには <code>__metaclass__</code> に指定したクラスの
<code>__new__</code> もしくは <code>__init__</code> をカスタマイズすることになります。</p>

<p><code>type</code> は <code>__init__</code> ではなく <code>__new__</code>
メソッドの方でクラス生成の主な作業を行っています (<a href="http://svn.python.org/projects/python/trunk/Objects/typeobject.c">typeobject.c
ソースコード</a>)。
そのため、 <code>type</code> の挙動をカスタマイズするには、普段オーバーライドする
<code>__init__</code> ではなくて、 <code>__new__</code>
メソッドをオーバーライドする必要があります。 そして <code>type.__new__</code>
を呼び出す前に引数の <code>name</code>, <code>bases</code>, <code>dict</code>
を編集してクラス生成をカスタマイズすることになります。</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">mymeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="c"># TODO: customize name, bases, dict.</span>
    <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span></code></pre></div>

<h1 id="section-1">メタクラスの例</h1>

<p><code>__metaclass__</code>
でどんなことができるのか理解するには例をみてみるのが一番だと思うので、
メタクラスのサンプルとして、<code>__metaclass__</code> に指定すると getter/setter
っぽい名前のメソッド (e.g. <code>get_name</code>, <code>getName</code>, <code>SetName</code>) を自動的に
<a href="http://docs.python.jp/2/library/functions.html#property">プロパティ</a>
に変換してくれるメタクラス <a href="https://github.com/yunabe/practice/tree/master/python/metaclass/">auto_property
(ソースコード)</a>
を作成しました。 例えば <code>get_x</code>
というメソッドを持つクラスに指定すると、アクセスすると <code>get_x</code>
が呼び出されるプロパティ <code>x</code> が自動的に生成されます。 （逆に <code>get_x</code>
はメソッドから消えます）</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">auto_property</span>

  <span class="k">def</span> <span class="nf">get_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">123</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">c</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">123</span></code></pre></div>

<h2 id="section-2">実装の解説</h2>

<p>まずは <code>type</code> を継承したクラス auto_property を定義します。 そして
<code>__new__</code> の中で引数として受け取ったクラス定義の辞書 <code>dict</code>
をカスタマイズしてから、 <code>type.__new__</code> を呼び出します。</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">auto_property</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="c"># TODO: dict から setter/getter っぽい名前のメソッドを取り除いて、</span>
    <span class="c">#       代わりに対応する property を持つ new_dict を作成する</span>
    <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">new_dict</span><span class="p">)</span></code></pre></div>

<p>後は、 TODO の部分で <code>dict</code> に対して for文を回して正規表現を使って
getter/setter と property 名を取り出して、 最後に <code>new_dict</code> に対して
<code>property(getter, setter)</code> を代入するだけです。</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">auto_property</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">setters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">getters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
      <span class="n">value</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
      <span class="c"># TODO: setter/getter を正規表現で検出</span>

    <span class="k">for</span> <span class="n">property_name</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
      <span class="n">getter</span> <span class="o">=</span> <span class="n">getters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">property_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
      <span class="n">setter</span> <span class="o">=</span> <span class="n">setters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">property_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
      <span class="n">new_dict</span><span class="p">[</span><span class="n">property_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getter</span><span class="p">,</span> <span class="n">setter</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">classname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">new_dict</span><span class="p">)</span></code></pre></div>

<p><a href="https://github.com/yunabe/practice/tree/master/python/metaclass/">githubにソースコードをコミットしてある</a>
ので、実装の細かい部分はそちらを確認して下さい。</p>


        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <div style="text-align:center">
          <a href="/docs">Home</a>
        </div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  console.log(fjs);
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.3";
  fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<script src="https://apis.google.com/js/platform.js" async defer>
  {lang: 'ja'}
</script>
<script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>


  </body>

</html>
