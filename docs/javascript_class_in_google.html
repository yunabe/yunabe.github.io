<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Google流 JavaScript におけるクラス定義の実現方法</title>
  <meta name="description" content="">
  <meta property="fb:admins" content="yunabe">
  <meta property="fb:app_id" content="234187763701556">
  <meta property="og:url" href="http://www.yunabe.jp/docs/javascript_class_in_google.html">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://www.yunabe.jp/docs/javascript_class_in_google.html">
  <link rel="alternate" type="application/rss+xml" title="" href="http://www.yunabe.jp/feed.xml">
  <script>
    if(location.host=='www.yunabe.jp'){
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-19477574-2', 'yunabe.jp');
    ga('require', 'displayfeatures');
    ga('send', 'pageview');
    }
  </script>
</head>


  <body>
    <div class="page-content">
      <div class="wrapper">
        <header class="post-header">
          <h1 class="post-title" itemprop="name headline">Google流 JavaScript におけるクラス定義の実現方法</h1>
          <p class="post-meta"><time datetime="2016-03-08T00:00:00+09:00" itemprop="datePublished">更新 Mar 8, 2016</time></p>
        </header>
        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <p>他のメジャーなオブジェクト指向プログラミング言語と異なりJavaScriptには「クラス」が存在しません。
代わりに C++, Java などにはない <code class="highlighter-rouge">prototype</code> や C++, Java のとは全く異なる <code class="highlighter-rouge">new</code> 演算子や <code class="highlighter-rouge">this</code> が用意されています。
これらの機能は一見するとどれもかなり奇妙な仕様をしています。
そのため、それぞれの機能の仕様を1つ1つ勉強しても一体全体何のためにそんな機能が用意されていて、
どのようにその機能を活用してプログラムを作ればよいのか全く理解できないと思います。</p>

<p>そのため C++, Java, Python
などの「まともな」オブジェクト指向プログラミング言語の経験のあるプログラマが
JavaScript で大規模なプログラミングを書こうとすると
クラスがないのにプログラムをどうやってモジュール化したらよいのか分からないし、
代わりにある <code class="highlighter-rouge">this</code> とか <code class="highlighter-rouge">prototype</code>
とかは何に使えばよいか分からないしで途方に暮れてしまうと思います。</p>

<p>しかし JavaScriptには「クラス」という言語仕様は用意されていないものの、<code class="highlighter-rouge">this</code>,
<code class="highlighter-rouge">prototype</code> などを一定のルールに基づいて利用すれば
他の言語のクラスほぼ同等のことは実現可能です。
つまり他のクラスで行うようなクラスを使ったカプセル化、ポリモーフィズム、継承などを
JavaScript でも実現することができます。 このドキュメントでは Google
が公開している JavaScript のオープンソースライブラリ <a href="https://developers.google.com/closure/library/">Google Closure
Library</a>
を参考にしてどのように JavaScript でクラスを実現すればよいかを学びます。</p>

<ul id="markdown-toc">
  <li><a href="#javascript-" id="markdown-toc-javascript-">クラス実現のために必要な JavaScript の言語仕様</a>    <ul>
      <li><a href="#function" id="markdown-toc-function">function</a></li>
      <li><a href="#this" id="markdown-toc-this">this</a></li>
      <li><a href="#call" id="markdown-toc-call">call</a></li>
      <li><a href="#new-" id="markdown-toc-new-">new 演算子</a></li>
      <li><a href="#prototype-" id="markdown-toc-prototype-">prototype チェーン</a></li>
      <li><a href="#prototype" id="markdown-toc-prototype">プロパティ: prototype</a></li>
    </ul>
  </li>
  <li><a href="#google-closure-" id="markdown-toc-google-closure-">Google Closure 流のクラスの実現方法の概要</a></li>
  <li><a href="#section" id="markdown-toc-section">クラスの宣言とコンストラクタの定義</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">メンバ変数 (インスタンス変数)</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">メソッド定義と呼び出し</a>    <ul>
      <li><a href="#private-protected" id="markdown-toc-private-protected">private, protected</a></li>
    </ul>
  </li>
  <li><a href="#section-3" id="markdown-toc-section-3">継承</a>    <ul>
      <li><a href="#section-4" id="markdown-toc-section-4">プロトタイプチェーンを利用してメソッドを親クラスから引き継ぐ</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">親クラスのコンストラクタの呼び出し</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">メソッドオーバーライドと親クラスのメソッドの呼び出し</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">多重継承</a></li>
      <li><a href="#abstract-interface" id="markdown-toc-abstract-interface">abstract, interface</a></li>
    </ul>
  </li>
  <li><a href="#inherits-" id="markdown-toc-inherits-">inherits の実際のコード</a></li>
  <li><a href="#section-8" id="markdown-toc-section-8">良くないクラス実現方法</a>    <ul>
      <li><a href="#prototype--" id="markdown-toc-prototype--">prototype = {}</a></li>
    </ul>
  </li>
  <li><a href="#es6-" id="markdown-toc-es6-">ES6 のクラス</a></li>
</ul>

<h1 id="javascript-">クラス実現のために必要な JavaScript の言語仕様</h1>

<p>JavaScript でのクラスの実現方法を理解するためには <code class="highlighter-rouge">this</code>, <code class="highlighter-rouge">new</code>,
<code class="highlighter-rouge">prototype</code>
などのJavaScriptの特殊な言語仕様を理解している必要があります。
まずはそうした JavaScript の言語仕様から復習しておきます。</p>

<h2 id="function">function</h2>

<p>JavaScript では <code class="highlighter-rouge">function</code> で関数を定義します。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>JavaScript
における関数の定義方法を知らない場合はクラスの実現方法を学ぶ前に、まず
JavaScript の入門書や
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions_and_function_scope">関数と関数スコープ</a>
などを読んだほうがよいかと思います。ここでは詳細は省略します。</p>

<h2 id="this">this</h2>

<p>JavaScript では <code class="highlighter-rouge">this</code> という特殊な変数が関数の中で利用可能です。
JavaScript の this は <strong>Java, C++ の this とは全く挙動が異なる</strong>
ので注意してください。 JavaScript の <code class="highlighter-rouge">this</code>
はある関数が呼び出された際にその関数を格納していた <code class="highlighter-rouge">object</code> を指します。
例えば</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">sayHelloShared</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello, I'm "</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<p>という関数があり、それが alice, bob というオブジェクトの <code class="highlighter-rouge">sayHello</code>
として登録されていたとします。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">alice</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">sayHello</span><span class="p">:</span> <span class="nx">sayHelloShared</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="s1">'Alice'</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">bob</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">sayHello</span><span class="p">:</span> <span class="nx">sayHelloShared</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="s1">'Bob'</span><span class="p">,</span>
  <span class="na">child</span><span class="p">:</span> <span class="nx">alice</span>
<span class="p">};</span></code></pre></figure>

<p>これを</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">alice</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span>  <span class="c1">// Hello, I'm Alice</span>
<span class="nx">bob</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span>  <span class="c1">// Hello, I'm Bob</span></code></pre></figure>

<p>のように呼び出すと前者の場合では <code class="highlighter-rouge">this</code> は <code class="highlighter-rouge">alice</code> を, 後者の場合では
<code class="highlighter-rouge">bob</code> を指すので それぞれの実行で <code class="highlighter-rouge">I'm Alice</code> と <code class="highlighter-rouge">I'm Bob</code>
が表示されます。 また下の例のように <code class="highlighter-rouge">.</code> が複数存在する場合は <code class="highlighter-rouge">this</code>
はその関数を直接格納していたオブジェクト <code class="highlighter-rouge">child</code> を参照します。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">bob</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span>  <span class="c1">// Hello, I'm Alice</span></code></pre></figure>

<p>なおクラスを実現する上ではあまり重要なことではないですが、 関数を単に
<code class="highlighter-rouge">method();</code> という形で単体で実行した場合には <code class="highlighter-rouge">this</code> は <code class="highlighter-rouge">window</code>
を指します。</p>

<h2 id="call">call</h2>

<p>関数呼び出しの際に <code class="highlighter-rouge">this</code> の明示的に指定することも可能です。 それには
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a>
を利用します。 <code class="highlighter-rouge">call</code>
は全ての関数が暗黙的に持っているプロパティで、関数として呼び出すことができます。
<code class="highlighter-rouge">call</code> を呼ぶと <code class="highlighter-rouge">call</code> の第一引数として渡されたオブジェクトが <code class="highlighter-rouge">this</code>
にセットされて元の関数が呼び出されます。
第二引数移行は元の関数の引数として利用されます。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">sayHelloShared</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">alice</span><span class="p">);</span>  <span class="c1">// Hello, I'm Alice</span>
<span class="nx">sayHelloShared</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">bob</span><span class="p">);</span>  <span class="c1">// Hello, I'm Bob</span></code></pre></figure>

<h2 id="new-">new 演算子</h2>

<p>JavaScript にも <code class="highlighter-rouge">new</code> 演算子が存在します。 ただし JavaScript の new も
<strong>Java や C++ でクラスのインスタンス化を行う new
とは全く動きが異なります。</strong> C++, Java では <code class="highlighter-rouge">new</code>
はクラスと共に利用しますが JavaScript の <code class="highlighter-rouge">new</code>
は任意の関数と一緒に呼び出します。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>new &lt;関数&gt;(&lt;引数&gt;);
</code></pre>
</div>

<p><code class="highlighter-rouge">new</code> と一緒に関数を呼び出すと、まず新しい空のオブジェクト (つまり <code class="highlighter-rouge"><span class="p">{}</span></code>)
が生成されます。 次に関数が呼び出されますが、その際に関数内の <code class="highlighter-rouge">this</code>
が生成されたオブジェクトを指すようになります。
関数が実行された後、生成されたオブジェクトが <code class="highlighter-rouge">new</code>
の実行結果として返されます。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'Alice'</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span></code></pre></figure>

<p>例えばこの例では、<code class="highlighter-rouge">new Person...</code>
によって新しいオブジェクトが生成され、それが <code class="highlighter-rouge">this</code> に格納されて
<code class="highlighter-rouge">Person</code> が実行され、 <code class="highlighter-rouge">name</code>, <code class="highlighter-rouge">age</code>
がオブジェクトにセットされます。そして生成されたオブジェクトは <code class="highlighter-rouge">alice</code>
に代入されます。 そのため、<code class="highlighter-rouge">alice.name</code>, <code class="highlighter-rouge">alice.age</code> は <code class="highlighter-rouge">Person</code>
に渡された引数 <code class="highlighter-rouge">name</code>, <code class="highlighter-rouge">age</code> になります。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">alice</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>  <span class="c1">// Alice</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">alice</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>  <span class="c1">// 7</span></code></pre></figure>

<p>もうお気づきのように、<code class="highlighter-rouge">new</code> 演算子を使うことで <code class="highlighter-rouge">JavaScript</code>
では関数を「コンストラクタ」として利用することができます。 実際 <code class="highlighter-rouge">new</code>
で生成されたオブジェクトは <code class="highlighter-rouge">constructor</code>
というプロパティで生成時に利用された関数への参照を保持しています。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">alice</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">==</span> <span class="nx">Person</span><span class="p">);</span>  <span class="c1">// true</span></code></pre></figure>

<h2 id="prototype-">prototype チェーン</h2>

<p>JavaScript のオブジェクトは基本的には key と value
のペアを保持する単なるマップ (連想配列) です。 <code class="highlighter-rouge">obj['prop'] = value;</code>
あるいは <code class="highlighter-rouge">obj.prop = value;</code>
のようにキーと値のペアを代入するとオブジェクトが内部的に保持しているマップにキーと値が保存されます。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">alice</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="s1">'Alice'</span><span class="p">,</span>  <span class="c1">// 'name': 'Alice' と同義</span>
<span class="p">};</span>
<span class="nx">alice</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>  <span class="c1">// alice['age'] = 7; と同義</span></code></pre></figure>

<p>登録した値は <code class="highlighter-rouge">obj['prop']</code> あるいは <code class="highlighter-rouge">obj.prop</code>
のように参照できます。参照されたキーが存在しない場合は <code class="highlighter-rouge">undefined</code>
が返されます。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// alice['name'] と alice.name は同義</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">alice</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>  <span class="c1">// Alice</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">alice</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>  <span class="c1">// 7</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">alice</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>  <span class="c1">// undefined</span></code></pre></figure>

<p>これがオブジェクトの基本動作です。しかし実は参照されたプロパティをオブジェクトが持っていなかった場合に、
他のオブジェクトからプロパティを探してきて参照するための仕組みが
JavaScript には用意されています。 それがプロトタイプチェーン (prototype
chain) と呼ばれるものです。</p>

<p>JavaScript のオブジェクトは他のオブジェクトを プロトタイプ
として利用することができます。
オブジェクのプロパティが参照された際、そのプロパティをオブジェクト自身が保持していない場合には代わりにプロトタイプのオブジェクトのプロパティが参照されます。
またプロトタイプのオブジェクトがそのプロパティを保持していない場合には、さらにプロトタイプのプロトタイプを参照します。
このようにプロトタイプとしてオブジェクトが鎖のように繋がれて、それが順々に参照されることからこの仕組は「プロトタイプチェーン」と呼ばれます。</p>

<p><img src="https://docs.google.com/drawings/d/1CjtvTFiPYQOICdGHG5jw-Vbf3Kh360_bho2utbrzeLY/pub?w=683&amp;h=171" width="341" height="85" /></p>

<p>なお <a href="http://www.ecma-international.org/ecma-262/5.1/">JavaScript
の仕様書</a> ではこの
プロトタイプ を表す内部的なプロパティを obj[[Prototype]]
のように記述します。
ただしこれは仕様書の中でのみ現れる表現であって、JavaScript
のコードの中では利用できません。 JavaScript で <code class="highlighter-rouge">obj</code>
のプロトタイプを参照するには <code class="highlighter-rouge">Object.getPrototypeOf(obj)</code> を使用します。
逆に <code class="highlighter-rouge">obj</code> のプロトタイプとして <code class="highlighter-rouge">proto</code> を設定するには
<code class="highlighter-rouge">Object.setPrototypeOf(obj, proto)</code> を利用します。</p>

<p>一部の JavaScript エンジンでは [[Prototype]] に相当する <code class="highlighter-rouge">__proto__</code>という特殊なプロパティが用意されていて、
このプロパティを参照、設定することでオブジェクトのプロトタイプを参照、設定することができます。
<del>ただしこれは<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">非標準の機能であり廃止される予定</a>なので今後はあまり利用しないほうがよいでしょう。</del>
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">ES6で__proto__が標準になりました</a>。ただ下位互換性の観点からあまり推奨されないことには変わりないかと思います。</p>

<h2 id="prototype">プロパティ: prototype</h2>

<p>プロトタイプの設定の方法はもう1つ存在します。それが関数の <code class="highlighter-rouge">prototype</code>
プロパティを使う方法です。 実は <code class="highlighter-rouge">function</code>
で作られた関数オブジェクトには <code class="highlighter-rouge">prototype</code>
というプロパティが存在し、空のオブジェクトが格納されています。
そしてその関数が <code class="highlighter-rouge">new</code>
演算子とともにコンストラクタとして実行された際に、<code class="highlighter-rouge">new</code>
で作成されたオブジェクト（つまり関数内では <code class="highlighter-rouge">this</code> が表すオブジェクト)
のプロトタイプとして関数の <code class="highlighter-rouge">prototype</code>
プロパティのオブジェクトが設定されます。</p>

<p>名前が非常に紛らわしいですが、 <strong>prototype
はオブジェクトのプロトタイプを表すプロパティではありません</strong>。
<code class="highlighter-rouge">prototype</code>
プロパティは「そのオブジェクトがコンストラクタとして利用された際に作成される新しいオブジェクト」のプロトタイプを決めるものです。
オブジェクトのプロトタイプを表すプロパティは <code class="highlighter-rouge">__proto__</code>
あるいは言語仕様書で [[Prototype]] と表されるもので <code class="highlighter-rouge">prototype</code>
プロパティとは異なります。
ここを勘違いしてしまうと混乱のもとになるので自分で図を書いたりコードを実行してよく違いを理解しておいて下さい。</p>

<p>さてこの <code class="highlighter-rouge">prototype</code>
というプロパティ、オブジェクトの直接のプロトタイプを表さないので一見非常に使いにくように思えます。
しかしこの特殊な仕様が JavaScript
でクラスを実現するにはとても重要になります。 実際、JavaScript
でプロトタイプを利用する場合 <code class="highlighter-rouge">setPrototypeOf</code>
よりもこちらを使うのが一般的です。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Constructor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>
<span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="s1">'Apple'</span><span class="p">;</span>
<span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="s1">'Banana'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Constructor</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">instance</span><span class="p">)</span> <span class="o">==</span> <span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>  <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>  <span class="c1">// 'Apple';</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span>  <span class="c1">// 'Banana';</span></code></pre></figure>

<h1 id="google-closure-">Google Closure 流のクラスの実現方法の概要</h1>

<p>まずクラスの実現方法の例を示して、それから各要素について解説します。
クラスの定義は次のような形になります。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// クラスとコンストラクタは関数を使って定義します</span>
<span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// this はインスタンスを表します。</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// メソッドはコンストラクタの prototype プロパティに定義します</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// メンバ変数の定義・参照は this.&lt;メンバ変数&gt; を使います。</span>
  <span class="c1">// C++, Java と違い this は省略できません。</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// メソッド内から他のメソッドを呼ぶ場合も this.&lt;メソッド&gt; を使います。</span>
  <span class="c1">// C++, Java と違い this は省略できません。</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Hello I\'m '</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span>
<span class="p">};</span></code></pre></figure>

<p>クラスをインスタンス化する際には <code class="highlighter-rouge">new</code> を使います。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'Alice'</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="nx">alice</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span></code></pre></figure>

<p>継承は <code class="highlighter-rouge">inherits</code> という関数を用意して次のように行います。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">inherits</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">childCtor</span><span class="p">,</span> <span class="nx">parentCtor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 子クラスの prototype のプロトタイプとして 親クラスの</span>
  <span class="c1">// prototype を指定することで継承が実現される</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">childCtor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">parentCtor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 子クラスのコンストラクタ</span>
<span class="kd">var</span> <span class="nx">Employee</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">,</span> <span class="nx">salary</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 親クラスのコンストラクタの呼び出しには call を使用</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">salary</span> <span class="o">=</span> <span class="nx">salary</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// inherits を使って親子関係を明示する</span>
<span class="nx">inherits</span><span class="p">(</span><span class="nx">Employee</span><span class="p">,</span> <span class="nx">Person</span><span class="p">);</span>

<span class="c1">// 子クラスのメソッド</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSalary</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">salary</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 同じ名前のメソッドを子クラスで定義すればオーバーライドになる。</span>
<span class="nx">Employee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 親クラスのメソッドを呼び出す場合は親クラスの prototype に</span>
  <span class="c1">// 定義されているメソッドを call を使って呼び出す。</span>
  <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Salary is '</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">salary</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<p>ではそれぞれの要素について解説していきましょう。</p>

<h1 id="section">クラスの宣言とコンストラクタの定義</h1>

<p>上で述べたように <code class="highlighter-rouge">new</code>
演算子をつかうと関数をクラスのコンストラクタのように利用することができます。
そのため JavaScript
では関数を使ってクラスとコンストラクタを同時に定義します。
クラスのインスタンスの生成とコンストラクタの呼び出しには <code class="highlighter-rouge">new</code>
演算子を使います。 上述したように JavaScript の <code class="highlighter-rouge">new</code> と C++/Javaの
<code class="highlighter-rouge">new</code>
の仕様は大きく異なりますが、結果的には似たような使い方をすることになります。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// クラス Person とそのコンストラクタを定義。インスタンス変数の設定にはコンストラクタ中で ``this.`` を使う。</span>
<span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// コンストラクタの中身</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'Alice'</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span></code></pre></figure>

<h1 id="section-1">メンバ変数 (インスタンス変数)</h1>

<p>上の例で出てきているように、クラスの内部でメンバ変数を定義・参照するには
<code class="highlighter-rouge">this.&lt;プロパティ名&gt;</code> を使います。 JavaScript では Java や C++ と違い
<strong>this を省略することは不可能</strong> なので注意してください。 Python
を知っている人は <code class="highlighter-rouge">this</code> は <code class="highlighter-rouge">self</code>
に相当するものだと思うと分かりやすいかと思います。
インスタンス変数やメソッド呼び出しの際に Python では <code class="highlighter-rouge">self</code>
を付けなければならないように JavaScript では <code class="highlighter-rouge">this</code> が必ず必要です。</p>

<h1 id="section-2">メソッド定義と呼び出し</h1>

<p>JavaScript でメソッドを定義するときにはコンストラクタ関数の <code class="highlighter-rouge">prototype</code>
オブジェクトに関数を定義します。
またメソッド内から他のメソッドの呼び出しを行う場合は
<code class="highlighter-rouge">this.&lt;メソッド名&gt;(引数)</code> を使います。
メンバ変数の場合と同様に、メソッド呼び出しの際に <strong>this
を省略することは不可能</strong> なので気をつけて下さい。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello, I'm "</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span>
<span class="p">};</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">'Alice'</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="nx">alice</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span></code></pre></figure>

<p>まず上述したように <code class="highlighter-rouge">alice</code> のコンストラクタ <code class="highlighter-rouge">Person</code> の <code class="highlighter-rouge">prototype</code>
プロパティ <code class="highlighter-rouge">Person.prototype</code> が alice のプロトタイプとなります。 つまり
<code class="highlighter-rouge">alice</code> に存在しないプロパティがアクセスされた場合、JavaScript は
<code class="highlighter-rouge">Person.prototype</code> から同名のプロパティを探してきます。 そのため、
<code class="highlighter-rouge">alice.sayHello</code> は <code class="highlighter-rouge">Person.prototype.sayHello</code>
になります(プロトタイプチェーン)。 さらに JavaScript では <code class="highlighter-rouge">this</code>
は関数が呼び出された際にその関数を保持していたオブジェクトがセットされるので、
<code class="highlighter-rouge">alice.sayHello();</code> という形で <code class="highlighter-rouge">sayHello</code> を呼び出した際には <code class="highlighter-rouge">this</code> は
<code class="highlighter-rouge">alice</code> となります。</p>

<p>このように <code class="highlighter-rouge">prototype</code> と <code class="highlighter-rouge">this</code>
の単体だと何のためにあるのか分からない奇妙な仕様がこのように。</p>

<p>上のメソッド定義の例をみると <code class="highlighter-rouge">this</code> が <code class="highlighter-rouge">prototype</code>
を指すのではないか？心配になるかもしれませんが前節で述べたように
JavaScript の <code class="highlighter-rouge">this</code>
は関数が呼び出された際にその関数をプロパティ保持していたオブジェクトを指します。そのため、
<code class="highlighter-rouge">alice.sayHello();</code> という形で <code class="highlighter-rouge">sayHello</code> を呼び出した場合は <code class="highlighter-rouge">this</code> は
<code class="highlighter-rouge">alice</code> を指すことになるのです。</p>

<h2 id="private-protected">private, protected</h2>

<p>JavaScript でクラスを実現する場合、メンバ変数やメソッドを <code class="highlighter-rouge">private</code> や
<code class="highlighter-rouge">protected</code> にすることはできません。 ただし名前規約で <code class="highlighter-rouge">private</code>
なものを名前でわかりやすくして間違えてアクセスしないようにすることはできます。
<a href="https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Naming">Google の JavaScript
のスタイルガイド</a>
では private なメソッド, メンバ変数は名前の末尾に <code class="highlighter-rouge">_</code>
をつけることが求められています。</p>

<h1 id="section-3">継承</h1>

<h2 id="section-4">プロトタイプチェーンを利用してメソッドを親クラスから引き継ぐ</h2>

<p>子クラスから親クラスのメソッドが引き継がれるようにするには、 子クラスの
<code class="highlighter-rouge">prototype</code> にメソッドが見つからなかった場合に、親クラスの <code class="highlighter-rouge">prototype</code>
に定義されてるメソッドが参照されれば良いので、 親クラスの <code class="highlighter-rouge">prototype</code>
が子クラスの <code class="highlighter-rouge">prototype</code> のプロトタイプ (<code class="highlighter-rouge">__proto__</code>, あるいは
[[Prototype]])になるようにします。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;figure&gt;
</code></pre>
</div>

<p>前述したように、<code class="highlighter-rouge">setPrototypeOf</code>
であるオブジェクトを他のオブジェクトのプロトタイプに設定できるので、次のような継承用の関数を事前に用意しておきます。
(Google Closure の実際の inherits は互換性のためにもう少し複雑です)</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">inherits</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">childCtor</span><span class="p">,</span> <span class="nx">parentCtor</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">childCtor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">parentCtor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<p>子クラスのコンストラクタを定義した後に、 <code class="highlighter-rouge">inherits(Child, Parent);</code>
のように呼び出して使います。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Parent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Parent のコンストラクタ実装</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">method0</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Parent.method0'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">Child</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Child のコンストラクタの実装</span>
<span class="p">};</span>

<span class="nx">inherits</span><span class="p">(</span><span class="nx">Child</span><span class="p">,</span> <span class="nx">Parent</span><span class="p">);</span>

<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">method1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Child.method1'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>
<span class="nx">child</span><span class="p">.</span><span class="nx">method0</span><span class="p">();</span>
<span class="nx">child</span><span class="p">.</span><span class="nx">method1</span><span class="p">();</span></code></pre></figure>

<h2 id="section-5">親クラスのコンストラクタの呼び出し</h2>

<p>上の例ではコンストラクタが空だったので問題ありませんでしたが、
現実のプログラムでは初期化を正しく行うためには子クラスのコンストラクタから
親クラスのコンストラクタを呼びださなくてはなりません。</p>

<p>親クラスのコンストラクタを呼び出す際には、親クラスのコンストラクタ内の
<code class="highlighter-rouge">this</code> が子クラスのコンストラクタ内の <code class="highlighter-rouge">this</code> (つまり <code class="highlighter-rouge">new</code>
で生成された初期化対象のインスタンス)
になるようにしなくてはなりません。<code class="highlighter-rouge">this</code>
を明示的に指定して関数を呼び出すには前述したように <code class="highlighter-rouge">call</code> を使います。
そのため親クラスのコンストラクタの呼び出しは
<code class="highlighter-rouge">Parent.call(this, 引数...)</code> のように行います。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Child</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Parent</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arg</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<h2 id="section-6">メソッドオーバーライドと親クラスのメソッドの呼び出し</h2>

<p>前述したように、<code class="highlighter-rouge">child.method0()</code> のようにメソッド呼び出しが行われると、
JavaScript はまず <code class="highlighter-rouge">child</code> のプロトタイプである <code class="highlighter-rouge">Child.prototype</code> から
<code class="highlighter-rouge">method</code> を探します。 <code class="highlighter-rouge">Child.prototype</code> に <code class="highlighter-rouge">method</code>
が見つからない場合は、さらにプロトタイプチェーンをたどって
<code class="highlighter-rouge">Parent.prototype</code> から <code class="highlighter-rouge">method</code> を探してきて呼び出します。</p>

<p>仕組み上、<code class="highlighter-rouge">C++</code> のようにオーバーライドする関数に <code class="highlighter-rouge">virtual</code>
などの特殊な修飾子を付ける必要はありません。 また <code class="highlighter-rouge">Java</code>
のようにメソッドに <code class="highlighter-rouge">final</code>
をつけてオーバーライドを禁止することもできません。
子クラスで同名のメソッドを定義されてしまえば問答無用でオーバーライドされてしまいます。
これは大規模なプログラムでは問題になってしまいますが、純粋な JavaScript
では解決する手段がありません。</p>

<p>また親クラスのメソッドを明示的に呼び出すには、親クラスのコンストラクタの呼び出しの場合と同様に
<code class="highlighter-rouge">call</code> を使用します。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Parent.prototype.sayHello(this);
</code></pre>
</div>

<h2 id="section-7">多重継承</h2>

<p>プロトタイプチェーンを利用している仕組み上、多重継承はできません。</p>

<h2 id="abstract-interface">abstract, interface</h2>

<p>JavaScript には <code class="highlighter-rouge">interface</code> や <code class="highlighter-rouge">abstract</code>
に相当する言語仕様は用意されていません。 Java, C++ の抽象メソッド
(abstract method) はメソッドの実体は定義せずに、
子クラスあるいはインターフェースを実装するクラスが実装しなくてはならないメソッドを宣言するものです。
Java, C++ は静的型チェックを行うのでそのような仕組みが必須です。 しかし
JavaScript
は型は動的にチェックされるので抽象メソッドはなくてもプログラムを書くことは可能です。</p>

<p>ただ現実にはプログラムの可読性を高めるために子クラスが実装しなくてはならないメソッドを明示的に書きたいと思うことも多いでしょう。
JavaScript
ではそのような場合、単純に例外を投げるだけの関数を定義してしまいます。これは
Python でも同じです。 Java の interface
に相当することをしたい場合はすべてのメソッドが例外を投げるだけのクラスを作成すればよいでしょう。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">()</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'Not Implemented'</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<h1 id="inherits-">inherits の実際のコード</h1>

<p>前述した継承用の関数 <code class="highlighter-rouge">inherits</code> は非常にシンプルでしたが、実際には
<code class="highlighter-rouge">setPrototypeOf</code> が利用できない古いブラウザの互換性のために、
同じことをもう少し複雑なコードで行う必要があります。 Google Closure の
<a href="https://github.com/google/closure-library/blob/master/closure/goog/base.js#L2170">base.js に定義されている
goog.inherits</a>
はブラウザ互換性のために <code class="highlighter-rouge">setPrototypeOf</code>
を使わず下のような少し複雑なコードになっています。</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">goog</span><span class="p">.</span><span class="nx">inherits</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">childCtor</span><span class="p">,</span> <span class="nx">parentCtor</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/** @constructor */</span>
  <span class="kd">function</span> <span class="nx">tempCtor</span><span class="p">()</span> <span class="p">{};</span>
  <span class="nx">tempCtor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">parentCtor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="nx">childCtor</span><span class="p">.</span><span class="nx">superClass_</span> <span class="o">=</span> <span class="nx">parentCtor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="nx">childCtor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">tempCtor</span><span class="p">();</span>
  <span class="cm">/** @override */</span>
  <span class="nx">childCtor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">childCtor</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<h1 id="section-8">良くないクラス実現方法</h1>

<h2 id="prototype--">prototype = {}</h2>

<p>メソッドの定義方法として、</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ....</span>
<span class="p">};</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">sayHello</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>
  <span class="na">getName</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ....</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>のように、<code class="highlighter-rouge">prototype</code>
を新しいオブジェクトで置き換えてしまうコードが揚げられている場合がありますが、
この方法だと、そのクラスが他のクラスを継承している場合にプロトタイプチェーンが切れてしまって継承関係が失われてしまうので
子クラスの定義では使えません。コードの一貫性を保つために、常に</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span></code></pre></figure>

<p>のように１つずつメソッドを追加するスタイルのほうが好ましいかと思います。
それと多くの場合問題になりませんが、<code class="highlighter-rouge">prototype</code>
を新しいオブジェクトで置き換えてしまうと、
<code class="highlighter-rouge">Person.prototype.constructor == Person</code>
の関係は壊れてしまうのでそこも若干マイナスポイントです。</p>

<h1 id="es6-">ES6 のクラス</h1>
<p><a href="javascript_class_es6.html">ECMAScript 6 (ES6) でようやくJavaScriptにもクラスの構文が追加されています</a>。数年後、ユーザが使っているブラウザの大半がECMAScript 6 をサポートするようになれば(2015年10月時点では最新のFirefoxではサポートされていない)、新規のプロジェクトや単なる趣味であればここに書かれている文法を直接使う必要はなくなると思います。
ただ下位互換性が非常に重要になるClosure Libraryのようなコアライブラリや既存のコード読む上で、あるいは<a href="https://github.com/google/traceur-compiler">ES6 to ES5 converter</a>の出力をデバッグする上で、今後少なくとも数年はもここに書かれている手段への理解は必要となるかと思います。
また<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">ES6のクラスがシンタックスシュガーに過ぎない</a>以上、ES6のクラスの挙動をきちんと理解したければプロトタイプを使ってどのようにクラスが実現できるのかを理解しておくのは今後も重要だと思います。ES6はあくまで既存のJavaScriptの上に作られた言語であり、JavaScriptがプロトタイプベースの言語であることは変わりません。</p>

        <div>
  <div style="display:inline-block;width:69px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="fb-like" data-layout="box_count" data-action="like" data-show-faces="false" data-share="false"></div>
  </div>
  <div style="display:inline-block;width:56px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="https://twitter.com/share" class="twitter-share-button" data-count="vertical"></a>
  </div>
  <div style="display:inline-block;width:50px;vertical-align:top;height:61px;margin-bottom:15px">
    <div class="g-plusone" data-size="tall"></div>
  </div>
  <div style="display:inline-block;width:80px;vertical-align:top;height:61px;margin-bottom:15px">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
  </div>
</div>

        <div class="fb-comments" data-href="http://www.yunabe.jp/docs/javascript_class_in_google.html"  data-numposts="5"></div>
        <div style="text-align:center">
          <a href="/docs">Home</a>
        </div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li></li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>

    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8&appId=234187763701556";
  fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));</script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<script src="https://apis.google.com/js/platform.js" async defer>
  {lang: 'ja'}
</script>
<script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>

    
  </body>

</html>
