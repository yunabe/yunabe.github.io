Why Events Are A Bad Idea の要点
================================
`Why Events Are A Bad Idea <http://www.cs.berkeley.edu/~brewer/papers/threads-hotos-2003.pdf>`_
を読んだので要点をまとめてみた。

論文の概要
----------
イベントモデルだとアプリケーションレベルで状態管理
（スレッドモデルではスタックとプログラムカウンタで保持されているもの）
とスケジューリング (スレッドモデルではカーネルによるスケジューリング) 
を自前で行うからスレッドライブラリの実装による数々の問題が回避できる。つまり

- イベントモデルのメリット == 既存のスレッドライブラリの抱える問題を自前の実装で回避可能 ということだと思う。
- 逆にスレッドライブラリ・プログラミング言語が提供してくれている便利な機能（そしてそれは通常のプログラミングで普段から利用しているものである。関数呼び出しとか例外処理とか）が使えなくなり、自前で実装する必要があるからコードが複雑なことになってマイナス面も多いよねってことかな。

以下は各章の要点

2.1 Duality Revisited
---------------------
根っこではイベントモデルとスレッドモデルは双対だよね。

2.2 “Problems” with Threads
---------------------------
Performance
~~~~~~~~~~~
- スレッドのスケジューリングのアルゴリズムにまずいところがあると困る。
- 例えばO(n)のアルゴリズムとか（この論文が書かれた時点ではGNU Pthには存在したっぽい、2012年現在はどうなのだろうね）。
- まあ、これはスレッドモデルそのものも問題じゃないよね。

Control Flow
~~~~~~~~~~~~
- スレッドモデルだと call/return パターン（普通の関数呼び出し + if-else, loop によるコントロールフロー）
  しか書けない。自由度が低いという批判。
- そもそもそんな複雑なモデルは使わないよね (We believe more complex patterns are not used because they are difficult to use well.)。
  大別すると

  #. call/return
  #. parallel calls
  #. pipeline になるよね。どれもtheradで書いたほうがずっと自然に書けるよね。

Synchronization
~~~~~~~~~~~~~~~
- イベントモデルだと synchchronization が不要で単純で済む。
- それはイベントモデルだとタスクが no preemption (cooperative multitasking) だからだよね。
  スレッドも preemption が起こらないような実装 (cooperative thread systems) にしたら同じメリットがあるよ。
  しかも multiprocessors の場合は成り立たないよね (とすでに2003年に言われている. 2012年携帯ですらマルチコア)

State Management
~~~~~~~~~~~~~~~~
- スレッドごとに stack 作るから仮想メモリ空間が足りなくなる 。stackサイズを小さくするとstack overflowする。
- イベント方式だとプログラマが state の管理を自前でする必要があるので、無駄なstateが保持されないで済む。
- 論文では言及されてないけど、仮想メモリ不足に関しては64bitになるとどうでもよくなる。
- 2番目の点に関しては、まあイベント特有のメリットと言えるかも。
  スレッドでもプログラマが注意すればstateは小さくできるけど、プログラマが注意しないと簡単に無駄なstateが保持されるから。

Scheduling
~~~~~~~~~~
スケジューリングがアプリケーションレベルで行えるので、
イベント方式だとアプリケーションレイヤの知識を利用してスケジューリングを最適化する余地がある。
例えば同種のイベントをまとめて処理すると
code locality を上げられるなど
（逆に同じデータは同じプロセッサで処理したほうが data locality が上がってよいケースもあるだろう）。

3 The Case for Threads
----------------------
大体の場合 concurrent requests はそもそも独立して処理される。

Control Flow
~~~~~~~~~~~~
イベントモデルだとプログラム理解する際に プログラマがプログラムを call-return のパターンに頭の中でマッチさせなくてはいけない
(The programmer must mentally match these call/return pairs)。
またイベントモデルで書く場合、stateの保持を自分で書かなくてはならならず(stack ripping)、
これがイベントモデルを使う際の大きな重荷となる (実際そう思う)。
あと、control flow が形式的に縛られなくなることで本来1つしか届かないメッセージが複数呼び出される(あるいはコールバックが必要以上に呼び出される)
ような問題が起こりやすい (言語やライブラリの仕様としてそういう事態を防ぐのは困難)。
あと既存のデバッグツールとの相性がよい（例えばスタックの状態の表示とか。イベントモデルで自前で状態管理してるとそういったツールからは扱いづらい）。

Exception Handling
~~~~~~~~~~~~~~~~~~
例外発生時の処理とかややこしいから言語の機能をそのまま使える
thread モデルのほうがよいよねという。 control flow の派生の話.
