JavaScript におけるクラスの実現
===============================

.. container:: editdate

  更新 2014年11月13日

他のメジャーなオブジェクト指向プログラミング言語と異なり JavaScript には「クラス」が存在しません。
代わりに C++, Java などにはない ``this`` や ``prototype``,  (C++, Java の ``new`` とは全く異なる) ``new`` 演算子が用意されています。
ただこれらの機能はどれもかなり奇妙な仕様をしています(少なくともC++, Java, Python などのプログラマにとっては)。
それぞれの機能の仕様だけ1つ1つ勉強しても一体全体何のためにそんな機能が用意されていて、
どのようにその機能を活用してプログラムを作ればよいのかは全く分からないと思います。

そのため C++, Java, Python などの「まともな」オブジェクト指向プログラミング言語の経験のあるプログラマが JavaScript で大規模なプログラミングを書こうとすると
クラスがないからプログラムをどうやってモジュール化したらよいのか分からないし、
代わりにある ``this`` とか ``prototype`` とかは何に使えばよいか分からないしで途方に暮れてしまうと思います。

しかし JavaScript にはクラスという言語仕様は用意されていないものの、``this``, ``prototype`` などを一定のルールに基づいて利用すれば
他の言語のクラスほぼ同等のことは実現可能です。
つまり他のクラスで行うようなクラスを使ったカプセル化、ポリモーフィズム、継承などを JavaScript でも実現することができます。
このドキュメントでは Google が作った JavaScript のオープンソースライブラリ
`Google Closure Library <https://developers.google.com/closure/library/>`_ を参考にしてどのように
JavaScript でクラスを実現すればよいかを学びます。

クラス実現のために必要な JavaScript の言語仕様
----------------------------------------------
function
~~~~~~~~
JavaScript では ``function`` で関数を定義します。

::

  var sum = function(a, b) {
    return a + b;
  }

JavaScript における関数の定義方法を知らない場合はクラスの実現方法を学ぶ前に、まず JavaScript の入門書や
`関数と関数スコープ <https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions_and_function_scope>`_
などを読んだほうがよいかと思います。ここでは詳細は省略します。

this
~~~~
JavaScript では ``this`` という特殊な変数が関数の中で利用可能です。
``this`` はその関数が呼び出された際に格納されていた ``object`` を指します。
例えば

::

  var sayHelloShared = function() {
    console.log("Hello, I'm" + this.name);
  };

という関数があり、それが alice, bob というオブジェクトの ``sayHello`` として登録されていたとします。

::

  var alice = {
    sayHello: sayHelloShared,
    name: 'Alice'
  };

  var bob = {
    sayHello: sayHelloShared,
    name: 'Bob',
    child: alice
  };

これを

::

  alice.sayHello();  // I'm Alice
  bob.sayHello();  // I'm Bob

のように呼び出すと前者の場合では ``this`` は ``alice`` を, 後者の場合では ``bob`` を指すので
それぞれの実行で ``I'm Alice`` と ``I'm Bob`` が表示されます。
また下の例のように ``.`` が複数存在する場合は ``this``
はその関数を直接格納していたオブジェクト ``child`` を参照します。

::
  
  bob.child.sayHello();  // I'm Alice

クラスを実現する上ではあまり重要なことではないですが、``obj.method();``
のような形ではなく関数を ``method();`` という形で単体で実行した場合には ``this`` は ``window`` を指します。

call
~~~~
関数呼び出しの際に ``this`` の明示的に指定することも可能です。
それには `call <https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/call>`_ を利用します。
``call`` は全ての関数が暗黙的に持っているプロパティで、 ``call`` の第一引数として渡されたオブジェクトが ``this`` にセットされて関数が呼び出されます。
残りの引数は元の関数と全くおなじになります。

new 演算子
~~~~~~~~~~
JavaScript にも ``new`` 演算子が存在します。
ただJavaScript の ``new`` は Java や C++ でクラスのインスタンス化を行う ``new`` とは全く動きが異なります。
C++, Java では ``new`` はクラスと共に利用しますが JavaScript の ``new`` は任意の関数と一緒に呼び出します。

::

  new <関数>(<引数>);

``new`` と一緒に関数を呼び出すと、まず新しい空のオブジェクト (つまり ``{}``, ``new Object();``) が生成されます。
次に関数が呼び出されますが、その際に関数内の ``this`` が生成されたオブジェクトを指すようになります。
関数が実行された後、生成されたオブジェクトが ``new`` の実行結果として返されます。

::

  var Person = function(name, age) {
    this.name = name;
    this.age = age;
  };

  var alice = new Person('Alice', 7);

例えばこの例では、``new Person...`` によって新しいオブジェクトが生成され、それが ``this`` に格納されて ``Person`` が実行され、
``name``, ``age`` がオブジェクトにセットされます。そして生成されたオブジェクトは ``alice`` に代入されます。
そのため、``alice.name``, ``alice.age`` は ``Person`` に渡された引数 ``name``, ``age`` になります。

::

  console.log(alice.name);  // Alice
  console.log(alice.age);  // 7

もうお気づきのように、``new`` 演算子を使うことで ``JavaScript`` では関数を「コンストラクタ」として利用することができます。
実際 ``new`` で生成されたオブジェクトは ``constructor`` というプロパティで生成時に利用された関数への参照を保持しています。

::

  console.log(alice.constructor == Person);  // true

prototype チェーン
~~~~~~~~~~~~~~~~~~
JavaScript のオブジェクトは基本的には key と value のペアを保持する単なるマップ (連想配列) です。
``obj['prop'] = value;`` あるいは ``obj.prop = value;`` のようにキーと値のペアを代入するとオブジェクトが内部的に保持しているマップにキーと値が保存されます。

::

  var alice = {
    name: 'Alice',  // 'name': 'Alice' と同義
  };
  alice.age = 7;  // alice['age'] = 7; と同義


登録した値は ``obj['prop']`` あるいは ``obj.prop`` のように参照できます。参照されたキーが存在しない場合は ``undefined`` が返されます。

::

  // alice['name'] と alice.name は同義
  console.log(alice.name]);  // Alice
  console.log(alice.age);  // 7
  console.log(alice.address);  // undefined

これがオブジェクトの基本動作です。しかし実はオブジェクトが参照されたプロパティを持っていなかった場合に、
他のオブジェクトのプロパティを代わりに参照することが JavaScript では可能です。
それがプロトタイプチェーン (prototype chain) と呼ばれるものです。

JavaScript のオブジェクトは ``__proto__`` という特殊なプロパティを持っています。
``__proto__`` 

https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/proto

JavaScript のオブジェクトは他のオブジェクトを `プロトタイプ` として利用することができます。
オブジェクのプロパティが参照された際、そのプロパティをオブジェクト自身が保持していない場合には代わりにプロトタイプのオブジェクトのプロパティが参照されます。
またプロトタイプのオブジェクトがそのプロパティを保持していない場合には、さらにプロトタイプのプロトタイプを参照します。
このようにプロトタイプとしてオブジェクトが鎖のように繋がれて、それが順々に参照されることからこの仕組は「プロトタイプチェーン」と呼ばれます。

::

  <figure>

あるオブジェクトを別のオブジェクトのプロトタイプとして指定するには ``Object.setPrototypeOf`` を利用します。
またあるオブジェクトのプロトタイプは ``Object.getPropertyOf`` で取得することができます。

もう一つのプロトタイプの設定の方法は、関数の ``prototype`` プロパティを使う方法です。
実は ``function`` で作られた関数オブジェクトには ``prototype`` というプロパティが存在し、空のオブジェクトが格納されています(要出典)。
そしてその関数が ``new`` 演算子とともにコンストラクタとして実行された際に、``new`` で作成されたオブジェクト（つまり関数内では ``this`` が表すオブジェクト)
のプロトタイプとして関数の ``prototype`` プロパティのオブジェクトが設定されます。

setPrototypeOf と違って直接オブジェクトのプロトタイプを指定しないので一見すると複雑でどのように使えばいいのか分かり難いですが、
JavaScript でクラスを実現するにはとても重要な機能です。JavaScript でプロトタイプを使う場合は ``setPrototypeOf`` よりもこちらを使うのが普通です。

::

  <figure>

::

  var Constructor = function() {};
  Constructor.prototype.a = 'Apple';
  Constructor.prototype.b = 'Banana';
  
  var instance = new Constructor();

  console.log(Object(setPrototypeOf(instance == Constructor.prototype);  // true
  console.log(instance.a);  // 'Apple';
  console.log(instance.b);  // 'Banana';

非常に紛らわしいですが、``obj.prototype`` プロパティは ``obj`` のプロトタイプを表すのではありません。
``Object.setPrototypeOf`` で取得できる ``obj`` のプロトタイプ (``obj`` にプロパティが見つからない場合に代わりにプロパティの参照を行うオブジェクト) と ``prototype`` は異なるオブジェクトです。名前が非常に紛らわしくて混乱しやすいので気をつけて下さい。

Google Closure 流のクラスの実現方法
===============================
クラスの宣言とコンストラクタの定義
----------------------------------
上で述べたように ``new`` 演算子をつかうと関数をクラスのコンストラクタのように利用することができます。
そのため JavaScript では関数を使ってクラスとコンストラクタを同時に定義することになります。
クラスのインスタンスの生成とコンストラクタの呼び出しには ``new`` 演算子を使います。
JavaScript の ``new`` の仕様は C++/Javaの ``new`` とは大きく異なりますが、結果的には似たような使い方をすることになります。

::

  // クラス Person とそのコンストラクタを定義。インスタンス変数の設定にはコンストラクタ中で ``this.`` を使う。
  var Person = function(name, age) {
    // コンストラクタの中身
  };

  var alice = new Person('Alice', 7);

メンバ変数 (インスタンス変数)
-----------------------------
上の例で出てきているように、メンバ変数の定義とアクセスには ``this.<プロパティ名>`` を使います。
上述したように

実は JavaScript の ``this`` は Python の ``self`` とほぼ同じように使われます。
インスタンス変数やメソッド呼び出しの際に Python では ``self`` を付けなければならないように JavaScript では ``this`` が必ず必要です。


メソッド定義
------------
JavaScript でメソッドを定義するときにはコンストラクタ関数の ``prototype`` オブジェクトに関数を定義します。

::

  Person.prototype.sayHello = function() {
    console.log("Hello, I'm " + this.name);
  };
 
  var alice = new Person('Alice', 7);
  alice.sayHello();

まず上述したように ``alice`` のコンストラクタ ``Person`` の ``prototype`` プロパティ ``Person.prototype`` が  alice のプロトタイプとなります。
つまり ``alice`` に存在しないプロパティがアクセスされた場合、JavaScript は ``Person.prototype`` から同名のプロパティを探してきます。
そのため、 ``alice.sayHello`` は ``Person.prototype.sayHello`` になります(プロトタイプチェーン)。
さらに JavaScript では ``this`` は関数が呼び出された際にその関数を保持していたオブジェクトがセットされるので、
``alice.sayHello();`` という形で ``sayHello`` を呼び出した際には ``this`` は ``alice`` となります。

このように ``prototype`` と ``this`` の単体だと何のためにあるのか分からない奇妙な仕様がこのように。

上のメソッド定義の例をみると ``this`` が ``prototype`` を指すのではないか？心配になるかもしれませんが前節で述べたように JavaScript の ``this`` は関数が呼び出された際にその関数をプロパティ保持していたオブジェクトを指します。そのため、 ``alice.sayHello();`` という形で ``sayHello`` を呼び出した場合は ``this`` は ``alice`` を指すことになるのです。

継承
----
プロトタイプチェーンを利用してメソッドを親クラスから引き継ぐ
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

  <figure>

::

  var inherits = function(childCtor, parentCtor) {
    Object.setPrototypeOf(childCtor.prototype, parentCtor.prototype);
  };

::

  var Parent = function(arg) {
    // Parent のコンストラクタ実装
  };

  var Parent.prototype.method0 = function() {
    console.log('Parent.method0');
  }

  var Child = function(arg) {
    // Child のコンストラクタの実装
  };

  inherits(Child, Parent);

  Child.prototype.method1 = function() {
    console.log('Child.method1');
  }

  var child = new Child();
  child.method0();
  child.method1();

親クラスのコンストラクタの呼び出し
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

::

  var Child = function(arg) {
    Parent.call(this, arg);
  };

メソッドオーバーライドと親クラスのメソッドの呼び出し
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
